<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Code on 为什么要演奏春日影！</title><link>https://guzhengsvt.github.io/zh-cn/categories/code/</link><description>Recent content in Code on 为什么要演奏春日影！</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Thu, 15 Feb 2024 11:44:33 +0800</lastBuildDate><atom:link href="https://guzhengsvt.github.io/zh-cn/categories/code/index.xml" rel="self" type="application/rss+xml"/><item><title>MicroPython函数库</title><link>https://guzhengsvt.github.io/zh-cn/post/code/micropython%E5%87%BD%E6%95%B0%E5%BA%93/</link><pubDate>Thu, 15 Feb 2024 11:44:33 +0800</pubDate><guid>https://guzhengsvt.github.io/zh-cn/post/code/micropython%E5%87%BD%E6%95%B0%E5%BA%93/</guid><description>&lt;h1 id="machine-与硬件相关功能">
&lt;a class="header-anchor" href="#machine-%e4%b8%8e%e7%a1%ac%e4%bb%b6%e7%9b%b8%e5%85%b3%e5%8a%9f%e8%83%bd">&lt;/a>
machine-与硬件相关功能
&lt;/h1>&lt;h2 id="pin类">
&lt;a class="header-anchor" href="#pin%e7%b1%bb">&lt;/a>
Pin类
&lt;/h2>&lt;h3 id="machinepinidmodenonepullnonevalue">
&lt;a class="header-anchor" href="#machinepinidmodenonepullnonevalue">&lt;/a>
&lt;code>machine.Pin(id,mode=None,pull=None,value)&lt;/code>
&lt;/h3>&lt;p>Pin对象构造函数&lt;/p>
&lt;ul>
&lt;li>id：GPIO编号，对于Pico为0-29&lt;/li>
&lt;li>mode：模式，可选&lt;code>None，Pin.IN(0),Pin.OUT(1),Pin.OPEN_DRAIN(2)&lt;/code>&lt;/li>
&lt;li>pull：使用内部上下拉电阻，仅在输入模式下有效，可选&lt;code>None,Pin.PULL_UP(1),Pin.DOWN(2)&lt;/code>&lt;/li>
&lt;li>value：输出或开漏模式下端口值，0为低电位，1为高电位&lt;/li>
&lt;/ul>
&lt;h3 id="pininitmodenonepullnone">
&lt;a class="header-anchor" href="#pininitmodenonepullnone">&lt;/a>
&lt;code>Pin.init(mode=None,pull=None)&lt;/code>
&lt;/h3>&lt;p>重新初始化GPIO口&lt;/p></description></item><item><title>数据结构实机实验报告8——关键路径</title><link>https://guzhengsvt.github.io/zh-cn/post/code/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E6%9C%BA%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A8%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/</link><pubDate>Tue, 12 Dec 2023 15:00:26 +0800</pubDate><guid>https://guzhengsvt.github.io/zh-cn/post/code/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E6%9C%BA%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A8%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/</guid><description>&lt;h2 id="a-问题分析">
&lt;a class="header-anchor" href="#a-%e9%97%ae%e9%a2%98%e5%88%86%e6%9e%90">&lt;/a>
a. 问题分析
&lt;/h2>&lt;p>在关键路径方法中，我们需要找到项目中的关键路径，即影响项目总持续时间的关键活动序列。为了解决这个问题，我们首先构建了一个表示项目活动的数据结构 &lt;code>Activity&lt;/code>，并设计了一个 &lt;code>Project&lt;/code> 类来处理项目的计算和输出。&lt;/p></description></item><item><title>数据结构实机实验报告7——Kruskal算法与最小生成树问题，Dijkstra算法与带权图最短路径问题</title><link>https://guzhengsvt.github.io/zh-cn/post/code/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E6%9C%BA%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A7kruskal%E7%AE%97%E6%B3%95%E4%B8%8E%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%97%AE%E9%A2%98dijkstra%E7%AE%97%E6%B3%95%E4%B8%8E%E5%B8%A6%E6%9D%83%E5%9B%BE%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</link><pubDate>Tue, 12 Dec 2023 14:58:44 +0800</pubDate><guid>https://guzhengsvt.github.io/zh-cn/post/code/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E6%9C%BA%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A7kruskal%E7%AE%97%E6%B3%95%E4%B8%8E%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%97%AE%E9%A2%98dijkstra%E7%AE%97%E6%B3%95%E4%B8%8E%E5%B8%A6%E6%9D%83%E5%9B%BE%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</guid><description>&lt;h1 id="kruskal算法生成最小生成树">
&lt;a class="header-anchor" href="#kruskal%e7%ae%97%e6%b3%95%e7%94%9f%e6%88%90%e6%9c%80%e5%b0%8f%e7%94%9f%e6%88%90%e6%a0%91">&lt;/a>
Kruskal算法生成最小生成树
&lt;/h1>&lt;h2 id="a-问题分析">
&lt;a class="header-anchor" href="#a-%e9%97%ae%e9%a2%98%e5%88%86%e6%9e%90">&lt;/a>
a 问题分析
&lt;/h2>&lt;p>我们需要使用 Kruskal 算法找到一个包含10个节点和20条边的图的最小生成树。Kruskal算法基于贪心思想，通过不断选择权重最小的边，并确保添加这条边不形成环路，来构建最小生成树。&lt;/p></description></item><item><title>数据结构实机实验报告6——前序、后续将二叉树线索化，图的邻接矩阵和邻接表的存储数据结构实机实验报告6——前序、后续将二叉树线索化，图的邻接矩阵和邻接表的存储</title><link>https://guzhengsvt.github.io/zh-cn/post/code/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E6%9C%BA%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A6%E5%89%8D%E5%BA%8F%E5%90%8E%E7%BB%AD%E5%B0%86%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BA%BF%E7%B4%A2%E5%8C%96%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%92%8C%E9%82%BB%E6%8E%A5%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E6%9C%BA%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A6%E5%89%8D%E5%BA%8F%E5%90%8E%E7%BB%AD%E5%B0%86%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BA%BF%E7%B4%A2%E5%8C%96%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%92%8C%E9%82%BB%E6%8E%A5%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8/</link><pubDate>Tue, 12 Dec 2023 14:56:33 +0800</pubDate><guid>https://guzhengsvt.github.io/zh-cn/post/code/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E6%9C%BA%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A6%E5%89%8D%E5%BA%8F%E5%90%8E%E7%BB%AD%E5%B0%86%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BA%BF%E7%B4%A2%E5%8C%96%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%92%8C%E9%82%BB%E6%8E%A5%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E6%9C%BA%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A6%E5%89%8D%E5%BA%8F%E5%90%8E%E7%BB%AD%E5%B0%86%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BA%BF%E7%B4%A2%E5%8C%96%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%92%8C%E9%82%BB%E6%8E%A5%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8/</guid><description>&lt;h1 id="前序后续将二叉树线索化">
&lt;a class="header-anchor" href="#%e5%89%8d%e5%ba%8f%e5%90%8e%e7%bb%ad%e5%b0%86%e4%ba%8c%e5%8f%89%e6%a0%91%e7%ba%bf%e7%b4%a2%e5%8c%96">&lt;/a>
前序、后续将二叉树线索化
&lt;/h1>&lt;h2 id="a-问题分析">
&lt;a class="header-anchor" href="#a-%e9%97%ae%e9%a2%98%e5%88%86%e6%9e%90">&lt;/a>
a. 问题分析
&lt;/h2>&lt;p>我们需要实现一个二叉树的前序线索化。线索化是一种将二叉链表中的空指针域改为指向该节点在某种遍历次序下的前驱节点或后继节点的方法。这样，我们就可以通过前序、中序或后序中的任何一个节点来开始，而不仅仅是从根节点开始。&lt;/p></description></item><item><title>数据结构实机实验报告5——哈夫曼树的编码和译码，排序二叉树的构建和节点删除</title><link>https://guzhengsvt.github.io/zh-cn/post/code/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E6%9C%BA%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A5%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E7%BC%96%E7%A0%81%E5%92%8C%E8%AF%91%E7%A0%81%E6%8E%92%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA%E5%92%8C%E8%8A%82%E7%82%B9%E5%88%A0%E9%99%A4/</link><pubDate>Tue, 12 Dec 2023 14:54:04 +0800</pubDate><guid>https://guzhengsvt.github.io/zh-cn/post/code/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E6%9C%BA%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A5%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E7%BC%96%E7%A0%81%E5%92%8C%E8%AF%91%E7%A0%81%E6%8E%92%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA%E5%92%8C%E8%8A%82%E7%82%B9%E5%88%A0%E9%99%A4/</guid><description>&lt;h1 id="实现哈夫曼树的编码和译码">
&lt;a class="header-anchor" href="#%e5%ae%9e%e7%8e%b0%e5%93%88%e5%a4%ab%e6%9b%bc%e6%a0%91%e7%9a%84%e7%bc%96%e7%a0%81%e5%92%8c%e8%af%91%e7%a0%81">&lt;/a>
实现哈夫曼树的编码和译码
&lt;/h1>&lt;h3 id="a-问题分析">
&lt;a class="header-anchor" href="#a-%e9%97%ae%e9%a2%98%e5%88%86%e6%9e%90">&lt;/a>
a. 问题分析
&lt;/h3>&lt;h4 id="目标">
&lt;a class="header-anchor" href="#%e7%9b%ae%e6%a0%87">&lt;/a>
目标：
&lt;/h4>&lt;p>实现哈夫曼树的编码和译码。&lt;/p>
&lt;h4 id="问题">
&lt;a class="header-anchor" href="#%e9%97%ae%e9%a2%98">&lt;/a>
问题：
&lt;/h4>&lt;ol>
&lt;li>构建哈夫曼树的过程是否正确？&lt;/li>
&lt;li>是否正确生成了哈夫曼编码？&lt;/li>
&lt;li>是否正确进行了哈夫曼编码和译码的过程？&lt;/li>
&lt;li>是否能够处理频率相同的字符？&lt;/li>
&lt;/ol>
&lt;h3 id="b-算法设计">
&lt;a class="header-anchor" href="#b-%e7%ae%97%e6%b3%95%e8%ae%be%e8%ae%a1">&lt;/a>
b. 算法设计
&lt;/h3>&lt;h4 id="1-构建哈夫曼树">
&lt;a class="header-anchor" href="#1-%e6%9e%84%e5%bb%ba%e5%93%88%e5%a4%ab%e6%9b%bc%e6%a0%91">&lt;/a>
1. 构建哈夫曼树：
&lt;/h4>&lt;ul>
&lt;li>根据输入的文本，计算字符的频率。&lt;/li>
&lt;li>使用优先队列（最小堆）构建哈夫曼树。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>输入：&lt;/strong> 字符频率的映射 &lt;code>frequencies&lt;/code>。
&lt;strong>输出：&lt;/strong> 哈夫曼树的根节点 &lt;code>root&lt;/code>。&lt;/p></description></item><item><title>数据结构实机实验报告4——二叉树的构建（完全二叉树BFS结果）、存储（顺序存储与链式存储）、遍历（BFS与DFS）</title><link>https://guzhengsvt.github.io/zh-cn/post/code/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E6%9C%BA%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A4%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91bfs%E7%BB%93%E6%9E%9C%E5%AD%98%E5%82%A8%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E9%81%8D%E5%8E%86bfs%E4%B8%8Edfs/</link><pubDate>Tue, 12 Dec 2023 14:43:54 +0800</pubDate><guid>https://guzhengsvt.github.io/zh-cn/post/code/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E6%9C%BA%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A4%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91bfs%E7%BB%93%E6%9E%9C%E5%AD%98%E5%82%A8%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E9%81%8D%E5%8E%86bfs%E4%B8%8Edfs/</guid><description>&lt;h1 id="1-根据输入创建二叉树顺序存储和链式存储">
&lt;a class="header-anchor" href="#1-%e6%a0%b9%e6%8d%ae%e8%be%93%e5%85%a5%e5%88%9b%e5%bb%ba%e4%ba%8c%e5%8f%89%e6%a0%91%e9%a1%ba%e5%ba%8f%e5%ad%98%e5%82%a8%e5%92%8c%e9%93%be%e5%bc%8f%e5%ad%98%e5%82%a8">&lt;/a>
1. 根据输入创建二叉树，顺序存储和链式存储
&lt;/h1>&lt;h2 id="a-问题分析">
&lt;a class="header-anchor" href="#a-%e9%97%ae%e9%a2%98%e5%88%86%e6%9e%90">&lt;/a>
a. 问题分析：
&lt;/h2>&lt;p>在这个问题中，需要根据输入的字符序列创建一个二叉树，要求实现两种存储方式：顺序存储和链式存储。输入的字符序列中，字符 &amp;lsquo;@&amp;rsquo; 表示空节点。&lt;/p></description></item><item><title>数据结构实机实验报告3——KMP算法用于字符串搜索</title><link>https://guzhengsvt.github.io/zh-cn/post/code/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E6%9C%BA%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A3kmp%E7%AE%97%E6%B3%95%E7%94%A8%E4%BA%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%90%9C%E7%B4%A2/</link><pubDate>Tue, 12 Dec 2023 14:42:01 +0800</pubDate><guid>https://guzhengsvt.github.io/zh-cn/post/code/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E6%9C%BA%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A3kmp%E7%AE%97%E6%B3%95%E7%94%A8%E4%BA%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%90%9C%E7%B4%A2/</guid><description>&lt;h1 id="实验目的">
&lt;a class="header-anchor" href="#%e5%ae%9e%e9%aa%8c%e7%9b%ae%e7%9a%84">&lt;/a>
&lt;strong>实验目的：&lt;/strong>
&lt;/h1>&lt;p>本实验旨在分析和测试KMP算法的实现，并研究其在字符串搜索中的应用。&lt;/p>
&lt;h1 id="实验内容">
&lt;a class="header-anchor" href="#%e5%ae%9e%e9%aa%8c%e5%86%85%e5%ae%b9">&lt;/a>
&lt;strong>实验内容：&lt;/strong>
&lt;/h1>&lt;h2 id="a-问题分析">
&lt;a class="header-anchor" href="#a-%e9%97%ae%e9%a2%98%e5%88%86%e6%9e%90">&lt;/a>
&lt;strong>a 问题分析：&lt;/strong>
&lt;/h2>&lt;ul>
&lt;li>如何构建最长前缀后缀匹配表（LPS数组）以提高搜索效率？&lt;/li>
&lt;li>如何在文本字符串中执行匹配，利用LPS数组来避免不必要的字符比较？&lt;/li>
&lt;li>如何设计算法以实现模式字符串的搜索？&lt;/li>
&lt;/ul>
&lt;h2 id="b-算法设计">
&lt;a class="header-anchor" href="#b-%e7%ae%97%e6%b3%95%e8%ae%be%e8%ae%a1">&lt;/a>
&lt;strong>b 算法设计：&lt;/strong>
&lt;/h2>&lt;p>KMP算法的设计包括以下关键步骤：&lt;/p></description></item><item><title>数据结构实机实验报告2——稀疏矩阵乘法</title><link>https://guzhengsvt.github.io/zh-cn/post/code/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E6%9C%BA%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/</link><pubDate>Tue, 12 Dec 2023 14:38:24 +0800</pubDate><guid>https://guzhengsvt.github.io/zh-cn/post/code/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E6%9C%BA%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/</guid><description>&lt;h1 id="问题分析">
&lt;a class="header-anchor" href="#%e9%97%ae%e9%a2%98%e5%88%86%e6%9e%90">&lt;/a>
问题分析
&lt;/h1>&lt;p>本实验的主要目标是开发一个稀疏矩阵乘法算法，该算法能够将两个稀疏矩阵 A 和 B 相乘，然后输出结果矩阵 C。在这个算法中，稀疏矩阵使用三元组表示，并且用户可以多次输入不同的矩阵数据，计算它们的乘积。&lt;/p></description></item><item><title>数据结构上机实验报告1——Fibonacci序列、划分子集问题</title><link>https://guzhengsvt.github.io/zh-cn/post/code/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A1fibonacci%E5%BA%8F%E5%88%97%E5%88%92%E5%88%86%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98/</link><pubDate>Tue, 12 Dec 2023 14:31:17 +0800</pubDate><guid>https://guzhengsvt.github.io/zh-cn/post/code/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A1fibonacci%E5%BA%8F%E5%88%97%E5%88%92%E5%88%86%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98/</guid><description>&lt;h1 id="fibonacci序列">
&lt;a class="header-anchor" href="#fibonacci%e5%ba%8f%e5%88%97">&lt;/a>
&lt;strong>Fibonacci序列&lt;/strong>
&lt;/h1>&lt;h2 id="问题分析">
&lt;a class="header-anchor" href="#%e9%97%ae%e9%a2%98%e5%88%86%e6%9e%90">&lt;/a>
&lt;strong>问题分析&lt;/strong>
&lt;/h2>&lt;p>要正确实现程序的递归调用和返回，必须解决参数的传递和返回地址问题。具体地说，进行调用时，每递归一次都要给所有参变量重新分配储存空间，并要把前一次调用的实参和本次调用后的返回地址保留。&lt;/p></description></item><item><title>Python基础数据结构</title><link>https://guzhengsvt.github.io/zh-cn/post/code/python%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link><pubDate>Sun, 27 Aug 2023 21:40:39 +0800</pubDate><guid>https://guzhengsvt.github.io/zh-cn/post/code/python%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid><description>&lt;p>&lt;strong>elem是单词element（元素）的缩写&lt;/strong>，在程序定义中代表某一不确定的类型，也就是抽象的数据类型。&lt;/p>
&lt;h1 id="list">
&lt;a class="header-anchor" href="#list">&lt;/a>
list
&lt;/h1>&lt;h2 id="定义">
&lt;a class="header-anchor" href="#%e5%ae%9a%e4%b9%89">&lt;/a>
定义
&lt;/h2>&lt;p>由一系列元素按顺序进行排列而成的容器&lt;/p></description></item><item><title>Python其他笔记</title><link>https://guzhengsvt.github.io/zh-cn/post/code/python%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/</link><pubDate>Tue, 27 Jun 2023 00:57:42 +0800</pubDate><guid>https://guzhengsvt.github.io/zh-cn/post/code/python%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/</guid><description>&lt;h1 id="注释">
&lt;a class="header-anchor" href="#%e6%b3%a8%e9%87%8a">&lt;/a>
注释
&lt;/h1>&lt;ul>
&lt;li>单行注释
$\#$内容&lt;/li>
&lt;li>多行注释&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="s1">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">你好这里绿色的部分是注释
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">这里也是
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">这里就不算注释了&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">#单行注释&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;&amp;#39;&amp;#39;&amp;#39;这里不是注释&amp;#39;&amp;#39;&amp;#39;你看会print出来吗？&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">a&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;&amp;#39;&amp;#39;你好&amp;#39;&amp;#39;&amp;#39;&lt;/span>&lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">终端&lt;/span>&lt;span class="err">：&lt;/span>&lt;span class="ne">SyntaxError&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">invalid&lt;/span> &lt;span class="n">syntax&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">这样写会报错，看来代码中间插入注释会影响运行
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">多行字符串可以用&amp;#39;&amp;#39;&amp;#39;&lt;/span>&lt;span class="n">字符串&lt;/span>&lt;span class="s1">&amp;#39;&amp;#39;&amp;#39;来定义，注释被解释为赋值操作，所以上面的报错指向末尾的1
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="编码格式">
&lt;a class="header-anchor" href="#%e7%bc%96%e7%a0%81%e6%a0%bc%e5%bc%8f">&lt;/a>
编码格式
&lt;/h1>&lt;ul>
&lt;li>在Python 2.x中，源文件默认编码格式为ASCII。如果内容中含有汉字，不指定编码格式的话，便不能正确的读取和输出。可以将下面的代码放到源文件的开头，来指定编码格式为UTF-8。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># -*- coding: UTF-8 -*-&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在Python 3.x中，源文件默认编码格式为UTF-8。故在使用Python 3.x时，通常不需要指定编码格式。&lt;/p></description></item><item><title>Python基础函数</title><link>https://guzhengsvt.github.io/zh-cn/post/code/python%E5%9F%BA%E7%A1%80%E5%87%BD%E6%95%B0/</link><pubDate>Tue, 27 Jun 2023 00:55:01 +0800</pubDate><guid>https://guzhengsvt.github.io/zh-cn/post/code/python%E5%9F%BA%E7%A1%80%E5%87%BD%E6%95%B0/</guid><description>&lt;h2 id="函数传参">
&lt;a class="header-anchor" href="#%e5%87%bd%e6%95%b0%e4%bc%a0%e5%8f%82">&lt;/a>
函数传参
&lt;/h2>&lt;p>python中，函数传递参数本质上是一种赋值操作&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">arr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">a&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">2&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol>
&lt;li>首先有两个变量arr和a，有两个对象1和2&lt;/li>
&lt;li>a绑定2，func(a)将a绑定的对象2贴上arr标签&lt;/li>
&lt;li>这时，对象1尚未创建，2贴上a标签和arr标签&lt;/li>
&lt;li>$arr=1$操作将2上arr标签撕下，创建对象1并贴上arr标签&lt;/li>
&lt;li>输出结果&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">2&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="输入输出">
&lt;a class="header-anchor" href="#%e8%be%93%e5%85%a5%e8%be%93%e5%87%ba">&lt;/a>
输入输出
&lt;/h2>&lt;h3 id="print函数">
&lt;a class="header-anchor" href="#print%e5%87%bd%e6%95%b0">&lt;/a>
print()函数
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span>&lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;字符串&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">字符串&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span>&lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;str1&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="s2">&amp;#34;str2&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="s2">&amp;#34;str3&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">str1&lt;/span> &lt;span class="n">str2&lt;/span> &lt;span class="n">str3&lt;/span>&lt;span class="c1">#空格取代逗号&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="o">**&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="c1">#会先计算数值再输出&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">sum&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="c1">#优先执行sum()函数&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>==原型==&lt;/strong>
&lt;/p></description></item><item><title>Python数据类型及运算符</title><link>https://guzhengsvt.github.io/zh-cn/post/code/python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E8%BF%90%E7%AE%97%E7%AC%A6/</link><pubDate>Tue, 27 Jun 2023 00:49:20 +0800</pubDate><guid>https://guzhengsvt.github.io/zh-cn/post/code/python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E8%BF%90%E7%AE%97%E7%AC%A6/</guid><description>&lt;h2 id="常量与变量">
&lt;a class="header-anchor" href="#%e5%b8%b8%e9%87%8f%e4%b8%8e%e5%8f%98%e9%87%8f">&lt;/a>
常量与变量
&lt;/h2>&lt;ul>
&lt;li>变量不需要声明类型&lt;/li>
&lt;li>python用$=$给变量赋值，用$==$比较两个值是否相等，相等返回True，不等返回False。&lt;/li>
&lt;li>变量使用前必须赋值（不同于C），变量只有赋值后才会被创建。
&lt;ul>
&lt;li>变量未定义异常&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">age&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">Traceback&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">most&lt;/span> &lt;span class="n">recent&lt;/span> &lt;span class="n">call&lt;/span> &lt;span class="n">last&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">File&lt;/span> &lt;span class="s2">&amp;#34;&amp;lt;stdin&amp;gt;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">line&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">module&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="ne">NameError&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">name&lt;/span> &lt;span class="s1">&amp;#39;age&amp;#39;&lt;/span> &lt;span class="ow">is&lt;/span> &lt;span class="ow">not&lt;/span> &lt;span class="n">defined&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>常量——不变的变量
&lt;strong>python没有任何机制保证变量不会改变对象，被改变时没有报错，没有C的const，所以使用时需要万分小心&lt;/strong>&lt;/p></description></item></channel></rss>