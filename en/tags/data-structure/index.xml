<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Data Structure on 孤筝の温暖小家</title><link>https://guzhengsvt.cn/en/tags/data-structure/</link><description>Recent content from 孤筝の温暖小家</description><generator>Hugo</generator><language>en</language><managingEditor>lvbowen040427@163.com (孤筝)</managingEditor><webMaster>lvbowen040427@163.com (孤筝)</webMaster><copyright>All website licensed under CC BY 4.0</copyright><lastBuildDate>Tue, 12 Dec 2023 15:00:26 +0800</lastBuildDate><atom:link href="https://guzhengsvt.cn/en/tags/data-structure/index.xml" rel="self" type="application/rss+xml"/><item><title>Data Structure Lab Report 8 - Critical Path</title><link>https://guzhengsvt.cn/en/post/code/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E6%9C%BA%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A8%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/</link><pubDate>Tue, 12 Dec 2023 15:00:26 +0800</pubDate><author>lvbowen040427@163.com (孤筝)</author><guid>https://guzhengsvt.cn/en/post/code/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E6%9C%BA%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A8%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/</guid><description><![CDATA[<h1>Data Structure Lab Report 8 - Critical Path</h1><p>作者: 孤筝 (lvbowen040427@163.com)</p>
          <h2 id="a-problem-analysis">
<a class="header-anchor" href="#a-problem-analysis"></a>
a. Problem Analysis
</h2><p>In the Critical Path Method (CPM), we need to identify the critical path in a project, which is the sequence of activities that determines the project&rsquo;s total duration. To solve this problem, we first construct a data structure <code>Activity</code> to represent project activities and design a <code>Project</code> class to handle project calculations and output.</p>
<p>The calculation of the critical path primarily relies on two key steps:</p>
<ol>
<li><strong>Earliest Start Time (ES) Calculation</strong>: Starting from the initial event, we use topological sorting and dynamic programming to compute the earliest start time for each activity.</li>
<li><strong>Latest Start Time (LS) Calculation</strong>: Starting from the final event, we perform a reverse traversal of the topological order and use dynamic programming to compute the latest start time for each activity.</li>
</ol>
<p>By comparing the earliest and latest start times, we can identify the activities on the critical path, which are crucial for determining the project&rsquo;s total duration.</p>
<h2 id="b-algorithm-design">
<a class="header-anchor" href="#b-algorithm-design"></a>
b. Algorithm Design
</h2><h3 id="1-calculating-earliest-start-time">
<a class="header-anchor" href="#1-calculating-earliest-start-time"></a>
1. Calculating Earliest Start Time
</h3><p>We use topological sorting and dynamic programming to compute the earliest start time. First, we identify all initial events (activities with no predecessors) and then traverse the graph starting from these events, updating the earliest start time for each activity.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// Calculate earliest start time
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">calculateEarliestStart</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">Activity</span><span class="o">&amp;</span> <span class="nl">activity</span> <span class="p">:</span> <span class="n">activities</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Traverse topological order
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">activity</span><span class="p">.</span><span class="n">next</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// If a node&#39;s adjacency list is empty (i.e., it&#39;s an initial event)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">activity</span><span class="p">.</span><span class="n">id</span><span class="p">);</span> <span class="c1">// Enqueue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">earliestStart</span><span class="p">[</span><span class="n">activity</span><span class="p">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Set earliest start time to 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// While queue is not empty
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">currentId</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span> <span class="c1">// Dequeue the highest-priority event (currentId)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">nextId</span> <span class="p">:</span> <span class="n">activities</span><span class="p">[</span><span class="n">currentId</span><span class="p">].</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Traverse currentId&#39;s adjacency list
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">earliestStart</span><span class="p">[</span><span class="n">nextId</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">earliestStart</span><span class="p">[</span><span class="n">nextId</span><span class="p">],</span> <span class="n">earliestStart</span><span class="p">[</span><span class="n">currentId</span><span class="p">]</span> <span class="o">+</span> <span class="n">activities</span><span class="p">[</span><span class="n">currentId</span><span class="p">].</span><span class="n">duration</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// nextId&#39;s earliest start time = max{current recorded earliest start time, predecessor currentId&#39;s earliest start time + currentId&#39;s duration}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">nextId</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="2-calculating-latest-start-time">
<a class="header-anchor" href="#2-calculating-latest-start-time"></a>
2. Calculating Latest Start Time
</h3><p>By traversing the topological order in reverse, we compute the latest start time. Starting from the final event, we iteratively update the latest start time for each activity.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// Calculate latest start time
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">calculateLatestStart</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">latestStart</span> <span class="o">=</span> <span class="n">earliestStart</span><span class="p">;</span> <span class="c1">// Initialize latest start time as earliest start time
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">activities</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Reverse traversal starting from the last event (i)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">nextId</span> <span class="p">:</span> <span class="n">activities</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">latestStart</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">latestStart</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">latestStart</span><span class="p">[</span><span class="n">nextId</span><span class="p">]</span> <span class="o">-</span> <span class="n">activities</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">duration</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// Current event&#39;s latest start time = min{recorded latest start time, next event nextId&#39;s latest start time - current event i&#39;s duration}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="c-data-structure-design">
<a class="header-anchor" href="#c-data-structure-design"></a>
c. Data Structure Design
</h2><p>We use two key data structures:</p>
<ol>
<li><strong><code>Activity</code> Struct</strong>: Represents a project activity, including the activity ID, duration, and subsequent activities.</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// Struct representing a project activity
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">Activity</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">id</span><span class="p">;</span>      <span class="c1">// Activity ID
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">duration</span><span class="p">;</span> <span class="c1">// Duration
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">next</span><span class="p">;</span> <span class="c1">// Subsequent activities
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><ol start="2">
<li><strong><code>Project</code> Class</strong>: Manages the project, including methods for adding activities, calculating earliest and latest start times, printing the critical path, and displaying time information.</li>
</ol>
<h2 id="d-debugging-process">
<a class="header-anchor" href="#d-debugging-process"></a>
d. Debugging Process
</h2><p>During debugging, we focused on the following aspects:</p>
<ol>
<li><strong>Data Structure Correctness</strong>: Ensuring the <code>Activity</code> struct and <code>Project</code> class accurately represent project and activity relationships.</li>
<li><strong>Algorithm Correctness</strong>: Verifying the correctness of the algorithms for calculating earliest and latest start times.</li>
<li><strong>Output Accuracy</strong>: Checking if the printed critical path and time information meet expectations.</li>
</ol>
<h2 id="e-output-results">
<a class="header-anchor" href="#e-output-results"></a>
e. Output Results
</h2><p>After running the program, we obtained the following output:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">Critical Path</span><span class="p">:</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="m">5</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">Activity 0</span><span class="p">:</span><span class="w"> </span><span class="l">ES=0, LS=0</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">Activity 1</span><span class="p">:</span><span class="w"> </span><span class="l">ES=2, LS=2</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">Activity 2</span><span class="p">:</span><span class="w"> </span><span class="l">ES=6, LS=6</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">Activity 3</span><span class="p">:</span><span class="w"> </span><span class="l">ES=9, LS=9</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">Activity 4</span><span class="p">:</span><span class="w"> </span><span class="l">ES=14, LS=14</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">Activity 5</span><span class="p">:</span><span class="w"> </span><span class="l">ES=16, LS=16</span><span class="w">
</span></span></span></code></pre></div><p>From the results, we can see that the critical path consists of activities 0, 1, 2, 3, 4, and 5. The earliest and latest start times for each activity are correctly calculated, confirming the effectiveness of our algorithm and data structure design.</p>
<h2 id="f-source-code">
<a class="header-anchor" href="#f-source-code"></a>
f. Source Code
</h2><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Struct representing a project activity
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">Activity</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">id</span><span class="p">;</span>      <span class="c1">// Activity ID
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">duration</span><span class="p">;</span> <span class="c1">// Duration
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">next</span><span class="p">;</span> <span class="c1">// Subsequent activities
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Project</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Activity</span><span class="o">&gt;</span> <span class="n">activities</span><span class="p">;</span> <span class="c1">// Vector storing project activities
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">earliestStart</span><span class="p">;</span>   <span class="c1">// Earliest start time
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">latestStart</span><span class="p">;</span>     <span class="c1">// Latest start time
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Add an activity
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="n">addActivity</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">duration</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">activities</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">id</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">next</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Calculate earliest start time
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="nf">calculateEarliestStart</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">Activity</span><span class="o">&amp;</span> <span class="nl">activity</span> <span class="p">:</span> <span class="n">activities</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Traverse topological order
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">activity</span><span class="p">.</span><span class="n">next</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// If a node&#39;s adjacency list is empty (i.e., it&#39;s an initial event)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">activity</span><span class="p">.</span><span class="n">id</span><span class="p">);</span> <span class="c1">// Enqueue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">earliestStart</span><span class="p">[</span><span class="n">activity</span><span class="p">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Set earliest start time to 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// While queue is not empty
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="kt">int</span> <span class="n">currentId</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span> <span class="c1">// Dequeue the highest-priority event (currentId)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">nextId</span> <span class="p">:</span> <span class="n">activities</span><span class="p">[</span><span class="n">currentId</span><span class="p">].</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Traverse currentId&#39;s adjacency list
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">earliestStart</span><span class="p">[</span><span class="n">nextId</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">earliestStart</span><span class="p">[</span><span class="n">nextId</span><span class="p">],</span> <span class="n">earliestStart</span><span class="p">[</span><span class="n">currentId</span><span class="p">]</span> <span class="o">+</span> <span class="n">activities</span><span class="p">[</span><span class="n">currentId</span><span class="p">].</span><span class="n">duration</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// nextId&#39;s earliest start time = max{current recorded earliest start time, predecessor currentId&#39;s earliest start time + currentId&#39;s duration}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">nextId</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Calculate latest start time
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="nf">calculateLatestStart</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">latestStart</span> <span class="o">=</span> <span class="n">earliestStart</span><span class="p">;</span> <span class="c1">// Initialize latest start time as earliest start time
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">activities</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Reverse traversal starting from the last event (i)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">nextId</span> <span class="p">:</span> <span class="n">activities</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">latestStart</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">latestStart</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">latestStart</span><span class="p">[</span><span class="n">nextId</span><span class="p">]</span> <span class="o">-</span> <span class="n">activities</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">duration</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// Current event&#39;s latest start time = min{recorded latest start time, next event nextId&#39;s latest start time - current event i&#39;s duration}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Print the critical path
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="nf">printCriticalPath</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Critical Path: &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">Activity</span><span class="o">&amp;</span> <span class="nl">activity</span> <span class="p">:</span> <span class="n">activities</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Traverse topological order
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">earliestStart</span><span class="p">[</span><span class="n">activity</span><span class="p">.</span><span class="n">id</span><span class="p">]</span> <span class="o">==</span> <span class="n">latestStart</span><span class="p">[</span><span class="n">activity</span><span class="p">.</span><span class="n">id</span><span class="p">])</span> <span class="p">{</span> <span class="c1">// Critical path activities have ES == LS
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">activity</span><span class="p">.</span><span class="n">id</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Print earliest and latest start times
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="nf">printTimeInfo</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">Activity</span><span class="o">&amp;</span> <span class="nl">activity</span> <span class="p">:</span> <span class="n">activities</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Activity &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">activity</span><span class="p">.</span><span class="n">id</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;: ES=&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">earliestStart</span><span class="p">[</span><span class="n">activity</span><span class="p">.</span><span class="n">id</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">                 <span class="o">&lt;&lt;</span> <span class="s">&#34;, LS=&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">latestStart</span><span class="p">[</span><span class="n">activity</span><span class="p">.</span><span class="n">id</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Constructor for initialization
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Project</span><span class="p">(</span><span class="kt">int</span> <span class="n">numActivities</span><span class="p">)</span> <span class="o">:</span> <span class="n">earliestStart</span><span class="p">(</span><span class="n">numActivities</span><span class="p">),</span> <span class="n">latestStart</span><span class="p">(</span><span class="n">numActivities</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Project</span> <span class="n">project</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span> <span class="c1">// Assume there are 6 activities
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Add activities in the format: activity ID, duration, subsequent activity IDs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">project</span><span class="p">.</span><span class="n">addActivity</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">{</span><span class="mi">1</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="n">project</span><span class="p">.</span><span class="n">addActivity</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="p">{</span><span class="mi">2</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="n">project</span><span class="p">.</span><span class="n">addActivity</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="p">{</span><span class="mi">3</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="n">project</span><span class="p">.</span><span class="n">addActivity</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="p">{</span><span class="mi">4</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="n">project</span><span class="p">.</span><span class="n">addActivity</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">{</span><span class="mi">5</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="n">project</span><span class="p">.</span><span class="n">addActivity</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">{});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Calculate earliest and latest start times
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">project</span><span class="p">.</span><span class="n">calculateEarliestStart</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">project</span><span class="p">.</span><span class="n">calculateLatestStart</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Print critical path and time information
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">project</span><span class="p">.</span><span class="n">printCriticalPath</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">project</span><span class="p">.</span><span class="n">printTimeInfo</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div>
        <hr><p>本文 2023-12-12 首发于 <a href='https://guzhengsvt.cn/'>孤筝の温暖小家</a>，最后修改于 2023-12-12</p><p>All website licensed under CC BY 4.0</p>]]></description><category>Code</category></item><item><title>Data Structure Lab Report 7 – Kruskal's Algorithm and the Minimum Spanning Tree Problem, Dijkstra's Algorithm and the Shortest Path Problem in Weighted Graphs</title><link>https://guzhengsvt.cn/en/post/code/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E6%9C%BA%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A7kruskal%E7%AE%97%E6%B3%95%E4%B8%8E%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%97%AE%E9%A2%98dijkstra%E7%AE%97%E6%B3%95%E4%B8%8E%E5%B8%A6%E6%9D%83%E5%9B%BE%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</link><pubDate>Tue, 12 Dec 2023 14:58:44 +0800</pubDate><author>lvbowen040427@163.com (孤筝)</author><guid>https://guzhengsvt.cn/en/post/code/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E6%9C%BA%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A7kruskal%E7%AE%97%E6%B3%95%E4%B8%8E%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%97%AE%E9%A2%98dijkstra%E7%AE%97%E6%B3%95%E4%B8%8E%E5%B8%A6%E6%9D%83%E5%9B%BE%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</guid><description><![CDATA[<h1>Data Structure Lab Report 7 – Kruskal's Algorithm and the Minimum Spanning Tree Problem, Dijkstra's Algorithm and the Shortest Path Problem in Weighted Graphs</h1><p>作者: 孤筝 (lvbowen040427@163.com)</p>
          <h1 id="kruskals-algorithm-for-generating-minimum-spanning-trees">
<a class="header-anchor" href="#kruskals-algorithm-for-generating-minimum-spanning-trees"></a>
Kruskal&rsquo;s Algorithm for Generating Minimum Spanning Trees
</h1><h2 id="a-problem-analysis">
<a class="header-anchor" href="#a-problem-analysis"></a>
a Problem Analysis
</h2><p>We need to use Kruskal&rsquo;s algorithm to find the minimum spanning tree (MST) for a graph with 10 nodes and 20 edges. Kruskal&rsquo;s algorithm is based on a greedy approach, constructing the MST by iteratively selecting edges with the smallest weights while ensuring no cycles are formed.</p>
<h2 id="b-algorithm-design">
<a class="header-anchor" href="#b-algorithm-design"></a>
b Algorithm Design
</h2><h3 id="key-steps-of-kruskals-algorithm">
<a class="header-anchor" href="#key-steps-of-kruskals-algorithm"></a>
Key Steps of Kruskal&rsquo;s Algorithm:
</h3><h4 id="edge-sorting">
<a class="header-anchor" href="#edge-sorting"></a>
<strong>Edge Sorting:</strong>
</h4><p>All edges are sorted in ascending order of their weights.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">sort</span><span class="p">(</span><span class="n">edges</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">edges</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="k">const</span> <span class="n">Edge</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Edge</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">weight</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">weight</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span></code></pre></div><p>The <code>sort</code> function sorts the elements in a container based on a specified comparison rule. Here, it sorts edges in ascending order of their weights, allowing Kruskal&rsquo;s algorithm to select edges with the smallest weights first.
1. <code>edges.begin()</code> and <code>edges.end()</code>: These parameters define the range of elements to be sorted. <code>begin()</code> returns an iterator to the first element, and <code>end()</code> returns an iterator to the position after the last element.
2. <code>[](const Edge&amp; a, const Edge&amp; b) { return a.weight &lt; b.weight; }</code>: This is a lambda expression that defines the comparison rule. It compares two edges <code>a</code> and <code>b</code> based on their weights and returns <code>true</code> if <code>a.weight</code> is less than <code>b.weight</code>, ensuring ascending order.
3. <code>const Edge&amp; a</code> and <code>const Edge&amp; b</code> are the parameters of the lambda function, representing the two edges being compared.
4. <code>return a.weight &lt; b.weight;</code> ensures that edges are sorted in ascending order of their weights.</p>
<h4 id="union-find-initialization">
<a class="header-anchor" href="#union-find-initialization"></a>
<strong>Union-Find Initialization:</strong>
</h4><p>Initialize the Union-Find (Disjoint Set Union, DSU) data structure, where each node is initially its own parent.</p>
<ul>
<li>The Union-Find data structure is used to manage sets of elements, supporting two primary operations: <code>Find</code> (to determine the root of an element) and <code>Union</code> (to merge two sets).</li>
<li><strong>Basic Operations:</strong>
<ol>
<li><strong>Find:</strong> Determines the root of an element, which identifies the set it belongs to.</li>
<li><strong>Union:</strong> Merges two sets by connecting their roots.</li>
</ol>
</li>
<li><strong>Implementation Details:</strong>
<ul>
<li>Typically implemented using arrays where each element&rsquo;s value represents its parent. Initially, each element is its own parent.</li>
</ul>
</li>
<li><strong>Optimizations:</strong>
<ul>
<li><strong>Path Compression:</strong> During the <code>Find</code> operation, the path from the element to its root is flattened, improving future <code>Find</code> operations.</li>
<li><strong>Union by Rank:</strong> During the <code>Union</code> operation, the smaller tree (in terms of depth) is attached to the root of the larger tree to keep the tree balanced and operations efficient.</li>
</ul>
</li>
</ul>
<h4 id="edge-traversal">
<a class="header-anchor" href="#edge-traversal"></a>
<strong>Edge Traversal:</strong>
</h4><p>Traverse the sorted edges, adding each edge to the MST if it does not form a cycle.</p>
<h3 id="implementation">
<a class="header-anchor" href="#implementation"></a>
Implementation:
</h3><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// Kruskal&#39;s Algorithm
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="n">kruskal</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;&amp;</span> <span class="n">edges</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numNodes</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Input: edge list and number of nodes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Sort edges by weight in ascending order
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">sort</span><span class="p">(</span><span class="n">edges</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">edges</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="k">const</span> <span class="n">Edge</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Edge</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="c1">// Parameters: start iterator, end iterator, lambda expression (comparison function)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">weight</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">weight</span><span class="p">;</span> <span class="c1">// Comparison rule: sort edges by weight in ascending order
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Initialize Union-Find
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">UnionFind</span> <span class="nf">uf</span><span class="p">(</span><span class="n">numNodes</span><span class="p">);</span> <span class="c1">// UnionFind(size)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Store edges of the MST
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Traverse sorted edges
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">Edge</span><span class="o">&amp;</span> <span class="nl">edge</span> <span class="p">:</span> <span class="n">edges</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Check if adding this edge forms a cycle
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">uf</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">start</span><span class="p">)</span> <span class="o">!=</span> <span class="n">uf</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">end</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// If the start and end nodes are in different sets (subtrees)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// No cycle formed, add edge to MST
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">edge</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">uf</span><span class="p">.</span><span class="n">unite</span><span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">start</span><span class="p">,</span> <span class="n">edge</span><span class="p">.</span><span class="n">end</span><span class="p">);</span> <span class="c1">// Merge the two subtrees (mark as the same set) to prevent cycles
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="c-data-structure-design">
<a class="header-anchor" href="#c-data-structure-design"></a>
c Data Structure Design
</h2><h3 id="1-edge-struct">
<a class="header-anchor" href="#1-edge-struct"></a>
1. <strong>Edge Struct:</strong>
</h3><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// Edge struct
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">Edge</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">weight</span><span class="p">;</span> <span class="c1">// Start node, end node, and weight of the edge
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><ul>
<li>The <code>Edge</code> struct represents an edge in the graph, containing the start node, end node, and weight.</li>
</ul>
<h3 id="2-unionfind-class">
<a class="header-anchor" href="#2-unionfind-class"></a>
2. <strong>UnionFind Class:</strong>
</h3><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// Union-Find implementation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">UnionFind</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">UnionFind</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="o">:</span> <span class="n">parent</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="n">rank</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">// `parent` stores the root of each node, initially set to itself; `rank` approximates tree depth, initialized to 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="c1">// Root initially set to itself
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Find the root of a node
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="p">{</span> <span class="c1">// If `x` is not its own parent (has an ancestor)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]);</span> <span class="c1">// Path compression: set parent to root
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">];</span> <span class="c1">// Return the root
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">unite</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Merge two subtrees
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">rootX</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="c1">// Root of `x`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">rootY</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">y</span><span class="p">);</span> <span class="c1">// Root of `y`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">rootX</span> <span class="o">!=</span> <span class="n">rootY</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// If `x` and `y` are in different sets (subtrees)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">rank</span><span class="p">[</span><span class="n">rootX</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">rank</span><span class="p">[</span><span class="n">rootY</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// If `x`&#39;s subtree is shallower than `y`&#39;s
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">parent</span><span class="p">[</span><span class="n">rootX</span><span class="p">]</span> <span class="o">=</span> <span class="n">rootY</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// Attach `x`&#39;s subtree to `y`&#39;s to avoid increasing depth
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rank</span><span class="p">[</span><span class="n">rootX</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">rank</span><span class="p">[</span><span class="n">rootY</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">parent</span><span class="p">[</span><span class="n">rootY</span><span class="p">]</span> <span class="o">=</span> <span class="n">rootX</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// If subtrees have the same depth
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">parent</span><span class="p">[</span><span class="n">rootX</span><span class="p">]</span> <span class="o">=</span> <span class="n">rootY</span><span class="p">;</span> <span class="c1">// Attach `x`&#39;s subtree to `y`&#39;s
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">rank</span><span class="p">[</span><span class="n">rootY</span><span class="p">]</span><span class="o">++</span><span class="p">;</span> <span class="c1">// Increment depth after merge
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">parent</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">rank</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><ul>
<li>The <code>UnionFind</code> class implements the Union-Find data structure for cycle detection. The <code>find</code> function locates the root of a node, and the <code>unite</code> function merges two sets.</li>
<li>In the constructor, the <code>rank</code> array is initialized to 0, representing the approximate depth of each tree. Initially, each node is its own tree with depth 0.</li>
<li>During <code>unite</code>, the <code>rank</code> array ensures that the smaller tree is attached to the larger one to maintain balance and efficiency.</li>
</ul>
<h2 id="d-debugging-process">
<a class="header-anchor" href="#d-debugging-process"></a>
d Debugging Process
</h2><p>During debugging, intermediate outputs (e.g., sorted edges, MST construction steps, and Union-Find states) were examined to verify the algorithm&rsquo;s correctness. Edge cases, such as disconnected graphs, were also tested.</p>
<h2 id="e-output">
<a class="header-anchor" href="#e-output"></a>
e Output
</h2><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="nl">Graph</span><span class="p">:</span>
</span></span><span class="line"><span class="cl"><span class="mi">0</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">4</span>
</span></span><span class="line"><span class="cl"><span class="mi">0</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">:</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">:</span> <span class="mi">8</span>
</span></span><span class="line"><span class="cl"><span class="mi">2</span> <span class="o">-</span> <span class="mi">5</span> <span class="o">:</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="mi">2</span> <span class="o">-</span> <span class="mi">6</span> <span class="o">:</span> <span class="mi">7</span>
</span></span><span class="line"><span class="cl"><span class="mi">3</span> <span class="o">-</span> <span class="mi">7</span> <span class="o">:</span> <span class="mi">5</span>
</span></span><span class="line"><span class="cl"><span class="mi">3</span> <span class="o">-</span> <span class="mi">8</span> <span class="o">:</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="mi">4</span> <span class="o">-</span> <span class="mi">9</span> <span class="o">:</span> <span class="mi">6</span>
</span></span><span class="line"><span class="cl"><span class="mi">5</span> <span class="o">-</span> <span class="mi">6</span> <span class="o">:</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="mi">6</span> <span class="o">-</span> <span class="mi">8</span> <span class="o">:</span> <span class="mi">6</span>
</span></span><span class="line"><span class="cl"><span class="mi">7</span> <span class="o">-</span> <span class="mi">9</span> <span class="o">:</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="mi">8</span> <span class="o">-</span> <span class="mi">9</span> <span class="o">:</span> <span class="mi">9</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="mi">3</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">:</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="mi">5</span> <span class="o">-</span> <span class="mi">7</span> <span class="o">:</span> <span class="mi">4</span>
</span></span><span class="line"><span class="cl"><span class="mi">6</span> <span class="o">-</span> <span class="mi">9</span> <span class="o">:</span> <span class="mi">7</span>
</span></span><span class="line"><span class="cl"><span class="mi">0</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">:</span> <span class="mi">6</span>
</span></span><span class="line"><span class="cl"><span class="mi">2</span> <span class="o">-</span> <span class="mi">8</span> <span class="o">:</span> <span class="mi">5</span>
</span></span><span class="line"><span class="cl"><span class="mi">4</span> <span class="o">-</span> <span class="mi">5</span> <span class="o">:</span> <span class="mi">4</span>
</span></span><span class="line"><span class="cl"><span class="n">Edges</span> <span class="n">in</span> <span class="n">the</span> <span class="n">minimum</span> <span class="n">spanning</span> <span class="nl">tree</span><span class="p">:</span>
</span></span><span class="line"><span class="cl"><span class="mi">0</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="mi">3</span> <span class="o">-</span> <span class="mi">8</span> <span class="o">:</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">:</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="mi">5</span> <span class="o">-</span> <span class="mi">6</span> <span class="o">:</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="mi">2</span> <span class="o">-</span> <span class="mi">5</span> <span class="o">:</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="mi">3</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">:</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="mi">7</span> <span class="o">-</span> <span class="mi">9</span> <span class="o">:</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="mi">5</span> <span class="o">-</span> <span class="mi">7</span> <span class="o">:</span> <span class="mi">4</span>
</span></span></code></pre></div><h2 id="f-source-code">
<a class="header-anchor" href="#f-source-code"></a>
f Source Code
</h2><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"> </span><span class="c1">// For `sort`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Edge struct
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">Edge</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">weight</span><span class="p">;</span> <span class="c1">// Start node, end node, and weight of the edge
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Union-Find implementation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">UnionFind</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">UnionFind</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="o">:</span> <span class="n">parent</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="n">rank</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">// `parent` stores the root of each node, initially set to itself; `rank` approximates tree depth, initialized to 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="c1">// Root initially set to itself
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Find the root of a node
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="p">{</span> <span class="c1">// If `x` is not its own parent (has an ancestor)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]);</span> <span class="c1">// Path compression: set parent to root
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">];</span> <span class="c1">// Return the root
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">unite</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Merge two subtrees
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">rootX</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="c1">// Root of `x`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">rootY</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">y</span><span class="p">);</span> <span class="c1">// Root of `y`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">rootX</span> <span class="o">!=</span> <span class="n">rootY</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// If `x` and `y` are in different sets (subtrees)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">rank</span><span class="p">[</span><span class="n">rootX</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">rank</span><span class="p">[</span><span class="n">rootY</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// If `x`&#39;s subtree is shallower than `y`&#39;s
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">parent</span><span class="p">[</span><span class="n">rootX</span><span class="p">]</span> <span class="o">=</span> <span class="n">rootY</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// Attach `x`&#39;s subtree to `y`&#39;s to avoid increasing depth
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rank</span><span class="p">[</span><span class="n">rootX</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">rank</span><span class="p">[</span><span class="n">rootY</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">parent</span><span class="p">[</span><span class="n">rootY</span><span class="p">]</span> <span class="o">=</span> <span class="n">rootX</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// If subtrees have the same depth
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">parent</span><span class="p">[</span><span class="n">rootX</span><span class="p">]</span> <span class="o">=</span> <span class="n">rootY</span><span class="p">;</span> <span class="c1">// Attach `x`&#39;s subtree to `y`&#39;s
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">rank</span><span class="p">[</span><span class="n">rootY</span><span class="p">]</span><span class="o">++</span><span class="p">;</span> <span class="c1">// Increment depth after merge
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">parent</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">rank</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Kruskal&#39;s Algorithm
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="n">kruskal</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;&amp;</span> <span class="n">edges</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numNodes</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Input: edge list and number of nodes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Sort edges by weight in ascending order
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">sort</span><span class="p">(</span><span class="n">edges</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">edges</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="k">const</span> <span class="n">Edge</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Edge</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="c1">// Parameters: start iterator, end iterator, lambda expression (comparison function)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">weight</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">weight</span><span class="p">;</span> <span class="c1">// Comparison rule: sort edges by weight in ascending order
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Initialize Union-Find
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">UnionFind</span> <span class="nf">uf</span><span class="p">(</span><span class="n">numNodes</span><span class="p">);</span> <span class="c1">// UnionFind(size)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Store edges of the MST
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Traverse sorted edges
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">Edge</span><span class="o">&amp;</span> <span class="nl">edge</span> <span class="p">:</span> <span class="n">edges</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Check if adding this edge forms a cycle
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">uf</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">start</span><span class="p">)</span> <span class="o">!=</span> <span class="n">uf</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">end</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// If the start and end nodes are in different sets (subtrees)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// No cycle formed, add edge to MST
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">edge</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">uf</span><span class="p">.</span><span class="n">unite</span><span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">start</span><span class="p">,</span> <span class="n">edge</span><span class="p">.</span><span class="n">end</span><span class="p">);</span> <span class="c1">// Merge the two subtrees (mark as the same set) to prevent cycles
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Create a graph with 10 nodes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">numNodes</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Manually define edges with start, end, and weight
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="n">edges</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">6</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">7</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">5</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Output the graph
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Graph:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">Edge</span><span class="o">&amp;</span> <span class="nl">edge</span> <span class="p">:</span> <span class="n">edges</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">edge</span><span class="p">.</span><span class="n">start</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; - &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">edge</span><span class="p">.</span><span class="n">end</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; : &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">edge</span><span class="p">.</span><span class="n">weight</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Run Kruskal&#39;s algorithm
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="n">minSpanningTree</span> <span class="o">=</span> <span class="n">kruskal</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">numNodes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Output edges in the MST
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Edges in the minimum spanning tree:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">Edge</span><span class="o">&amp;</span> <span class="nl">edge</span> <span class="p">:</span> <span class="n">minSpanningTree</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">edge</span><span class="p">.</span><span class="n">start</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; - &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">edge</span><span class="p">.</span><span class="n">end</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; : &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">edge</span><span class="p">.</span><span class="n">weight</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h1 id="dijkstras-algorithm-for-solving-shortest-path-in-weighted-graphs">
<a class="header-anchor" href="#dijkstras-algorithm-for-solving-shortest-path-in-weighted-graphs"></a>
Dijkstra&rsquo;s Algorithm for Solving Shortest Path in Weighted Graphs
</h1><h2 id="a-problem-analysis-1">
<a class="header-anchor" href="#a-problem-analysis-1"></a>
a Problem Analysis
</h2><p>The code implements Dijkstra&rsquo;s algorithm to solve the single-source shortest path problem in a weighted graph. Given an adjacency matrix representation of the graph, the algorithm computes the shortest distances from a specified start node to all other nodes.</p>
<h2 id="b-algorithm-design-1">
<a class="header-anchor" href="#b-algorithm-design-1"></a>
b Algorithm Design
</h2><h3 id="1-initialization">
<a class="header-anchor" href="#1-initialization"></a>
1. Initialization
</h3><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">graph</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">distances</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">INF</span><span class="p">);</span>
</span></span></code></pre></div><ul>
<li><strong>Analysis:</strong> The number of nodes <code>n</code> is determined from the graph&rsquo;s size. The <code>distances</code> array is initialized with <code>INF</code> (infinity), representing initially unknown distances.</li>
</ul>
<h3 id="2-priority-queue-setup">
<a class="header-anchor" href="#2-priority-queue-setup"></a>
2. Priority Queue Setup
</h3><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="n">greater</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;&gt;</span> <span class="n">pq</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">distances</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">pq</span><span class="p">.</span><span class="n">push</span><span class="p">({</span><span class="mi">0</span><span class="p">,</span> <span class="n">start</span><span class="p">});</span>
</span></span></code></pre></div><ul>
<li><strong>Analysis:</strong> A priority queue <code>pq</code> is created to manage nodes by their current shortest distance. The start node&rsquo;s distance is set to 0, and it is added to the queue.</li>
</ul>
<h3 id="3-main-loop">
<a class="header-anchor" href="#3-main-loop"></a>
3. Main Loop
</h3><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">pq</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">pq</span><span class="p">.</span><span class="n">top</span><span class="p">().</span><span class="n">second</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">pq</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">distances</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">distances</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">distances</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="n">pq</span><span class="p">.</span><span class="n">push</span><span class="p">({</span><span class="n">distances</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">v</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li><strong>Analysis:</strong> The loop extracts the node <code>u</code> with the smallest current distance. For each neighbor <code>v</code> of <code>u</code>, if a shorter path is found via <code>u</code>, the distance is updated, and <code>v</code> is added to the queue.</li>
</ul>
<h3 id="4-termination">
<a class="header-anchor" href="#4-termination"></a>
4. Termination
</h3><ul>
<li><strong>Analysis:</strong> The algorithm terminates when the queue is empty, having processed all nodes and finalized their shortest distances.</li>
</ul>
<h2 id="c-data-structure-design-1">
<a class="header-anchor" href="#c-data-structure-design-1"></a>
c Data Structure Design
</h2><h3 id="1-graph-adjacency-matrix">
<a class="header-anchor" href="#1-graph-adjacency-matrix"></a>
1. Graph (Adjacency Matrix)
</h3><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">Graph</span><span class="p">;</span>
</span></span></code></pre></div><ul>
<li><strong>Analysis:</strong> The <code>Graph</code> is represented as a 2D vector where <code>graph[u][v]</code> holds the weight of the edge from node <code>u</code> to <code>v</code>. A weight of 0 indicates no edge.</li>
</ul>
<h3 id="2-distances-array">
<a class="header-anchor" href="#2-distances-array"></a>
2. Distances Array
</h3><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">distances</span><span class="p">;</span>
</span></span></code></pre></div><ul>
<li><strong>Analysis:</strong> The <code>distances</code> array stores the shortest known distances from the start node to each node, initialized to <code>INF</code> and updated during the algorithm&rsquo;s execution.</li>
</ul>
<h3 id="3-priority-queue">
<a class="header-anchor" href="#3-priority-queue"></a>
3. Priority Queue
</h3><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="n">greater</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;&gt;</span> <span class="n">pq</span><span class="p">;</span>
</span></span></code></pre></div><ul>
<li><strong>Analysis:</strong> The priority queue <code>pq</code> holds pairs of distances and nodes, ordered by distance. The <code>greater</code> comparator ensures the smallest distance is always processed first.</li>
</ul>
<h2 id="d-debugging-process-1">
<a class="header-anchor" href="#d-debugging-process-1"></a>
d Debugging Process
</h2><ul>
<li>Intermediate outputs (e.g., queue states, distance updates) were logged to verify correctness.</li>
<li>Edge cases (e.g., no edges, negative weights) were tested to ensure robustness.</li>
<li>Multiple test cases confirmed the algorithm&rsquo;s accuracy and efficiency.</li>
</ul>
<h2 id="e-output-1">
<a class="header-anchor" href="#e-output-1"></a>
e Output
</h2><p>The final output shows the shortest distances from the start node to all other nodes, matching expectations.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">Distance</span> <span class="n">from</span> <span class="n">node</span> <span class="mi">0</span> <span class="n">to</span> <span class="mi">0</span><span class="o">:</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="n">Distance</span> <span class="n">from</span> <span class="n">node</span> <span class="mi">0</span> <span class="n">to</span> <span class="mi">1</span><span class="o">:</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="n">Distance</span> <span class="n">from</span> <span class="n">node</span> <span class="mi">0</span> <span class="n">to</span> <span class="mi">2</span><span class="o">:</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="n">Distance</span> <span class="n">from</span> <span class="n">node</span> <span class="mi">0</span> <span class="n">to</span> <span class="mi">3</span><span class="o">:</span> <span class="mi">9</span>
</span></span><span class="line"><span class="cl"><span class="n">Distance</span> <span class="n">from</span> <span class="n">node</span> <span class="mi">0</span> <span class="n">to</span> <span class="mi">4</span><span class="o">:</span> <span class="mi">6</span>
</span></span></code></pre></div><h2 id="f-source-code-1">
<a class="header-anchor" href="#f-source-code-1"></a>
f Source Code
</h2><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp"> </span><span class="c1">// For priority_queue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;climits&gt;</span><span class="cp"> </span><span class="c1">// For INT_MAX
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#define INF INT_MAX
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// Graph representation using adjacency matrix
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">Graph</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 2D vector where graph[u][v] represents the weight of the edge from node `u` to `v`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// Dijkstra&#39;s Algorithm
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">dijkstra</span><span class="p">(</span><span class="k">const</span> <span class="n">Graph</span><span class="o">&amp;</span> <span class="n">graph</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">distances</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Input: graph, start node, and distances array
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">graph</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="c1">// Number of nodes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">distances</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">INF</span><span class="p">);</span>  <span class="c1">// Initialize distances to infinity
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Priority queue to manage nodes by their current shortest distance
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="n">greater</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;&gt;</span> <span class="n">pq</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Pairs are {distance, node}, stored in a vector, ordered by distance (smallest first)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="n">distances</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// Distance from start to itself is 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">pq</span><span class="p">.</span><span class="n">push</span><span class="p">({</span><span class="mi">0</span><span class="p">,</span> <span class="n">start</span><span class="p">});</span>   <span class="c1">// Add start node to the queue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">pq</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">pq</span><span class="p">.</span><span class="n">top</span><span class="p">().</span><span class="n">second</span><span class="p">;</span>  <span class="c1">// Extract the node with the smallest current distance
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">pq</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">v</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">distances</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">distances</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// If a shorter path to `v` is found via `u`, update the distance
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">distances</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="n">pq</span><span class="p">.</span><span class="n">push</span><span class="p">({</span><span class="n">distances</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">v</span><span class="p">});</span>  <span class="c1">// Add the updated distance and node to the queue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Example graph represented as an adjacency matrix
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Graph</span> <span class="n">graph</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
</span></span></code></pre></div>
        <hr><p>本文 2023-12-12 首发于 <a href='https://guzhengsvt.cn/'>孤筝の温暖小家</a>，最后修改于 2023-12-12</p><p>All website licensed under CC BY 4.0</p>]]></description><category>Code</category></item></channel></rss>