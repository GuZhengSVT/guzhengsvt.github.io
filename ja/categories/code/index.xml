<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel><title>Code on 孤筝の温暖小家</title>
    <link>http://localhost:1313/ja/categories/code/</link>
    <description>Recent content from 孤筝の温暖小家</description>
    <generator>Hugo</generator>
    <language>ja</language>
    <managingEditor>lvbowen040427@163.com (孤筝)</managingEditor>
    <webMaster>lvbowen040427@163.com (孤筝)</webMaster>
    
    <copyright>All website licensed under CC BY 4.0</copyright>
    
    <lastBuildDate>Thu, 15 Feb 2024 11:44:33 +0800</lastBuildDate>
    
    <atom:link href="http://localhost:1313/ja/categories/code/index.xml" rel="self" type="application/rss&#43;xml" />
    
    
      
    
    
    
    <item>
      <title>MicroPython関数ライブラリ</title>
      <link>http://localhost:1313/ja/post/code/micropython%E5%87%BD%E6%95%B0%E5%BA%93/</link>
      <pubDate>Thu, 15 Feb 2024 11:44:33 &#43;0800</pubDate><author>lvbowen040427@163.com (孤筝)</author>
      <guid>http://localhost:1313/ja/post/code/micropython%E5%87%BD%E6%95%B0%E5%BA%93/</guid>
      <description><![CDATA[<h1>MicroPython関数ライブラリ</h1><p>作者: 孤筝 (lvbowen040427@163.com)</p>
          <h1 id="machine-ハードウェア関連機能">
<a class="header-anchor" href="#machine-%e3%83%8f%e3%83%bc%e3%83%89%e3%82%a6%e3%82%a7%e3%82%a2%e9%96%a2%e9%80%a3%e6%a9%9f%e8%83%bd"></a>
machine-ハードウェア関連機能
</h1><h2 id="pinクラス">
<a class="header-anchor" href="#pin%e3%82%af%e3%83%a9%e3%82%b9"></a>
Pinクラス
</h2><h3 id="machinepinidmodenonepullnonevalue">
<a class="header-anchor" href="#machinepinidmodenonepullnonevalue"></a>
<code>machine.Pin(id,mode=None,pull=None,value)</code>
</h3><p>Pinオブジェクトコンストラクタ</p>
<ul>
<li>id：GPIO番号、Picoでは0-29</li>
<li>mode：モード、オプション<code>None、Pin.IN(0)、Pin.OUT(1)、Pin.OPEN_DRAIN(2)</code></li>
<li>pull：内部プルアップ/プルダウン抵抗の使用、入力モードでのみ有効、オプション<code>None、Pin.PULL_UP(1)、Pin.DOWN(2)</code></li>
<li>value：出力またはオープンドレインモードでのポート値、0は低電位、1は高電位</li>
</ul>
<h3 id="pininitmodenonepullnone">
<a class="header-anchor" href="#pininitmodenonepullnone"></a>
<code>Pin.init(mode=None,pull=None)</code>
</h3><p>GPIOポートの再初期化</p>
<h3 id="pinvaluex">
<a class="header-anchor" href="#pinvaluex"></a>
<code>Pin.value([x])</code>
</h3><ul>
<li>パラメータなしの場合、GPIOポートの値を返す</li>
<li>パラメータ0または1を指定すると、GPIOポートに値を書き込む</li>
</ul>
<h3 id="pintoggle">
<a class="header-anchor" href="#pintoggle"></a>
<code>Pin.toggle()</code>
</h3><p>出力またはオープンドレインモードでポートの状態を反転
例.LED点滅</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">machine</span> <span class="kn">import</span> <span class="n">Pin</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">time</span>
</span></span><span class="line"><span class="cl"><span class="n">led</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span><span class="n">Pin</span><span class="o">.</span><span class="n">OUT</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="kc">True</span> <span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">led</span><span class="o">.</span><span class="n">toggle</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="c1">#1秒ごとにLEDのON/OFFを切り替え</span>
</span></span></code></pre></div><h3 id="pinirqhandlernonetriggerpinirq_fallingpinirq_rising">
<a class="header-anchor" href="#pinirqhandlernonetriggerpinirq_fallingpinirq_rising"></a>
<code>Pin.irq(handler=None,trigger=(Pin.IRQ_FALLING|PIN.IRQ_RISING))</code>
</h3><p>外部割り込み関数</p>
<ul>
<li>handler：割り込みトリガーコールバック関数</li>
<li>trigger：割り込みトリガー条件（エッジトリガー/レベルトリガー）</li>
</ul>
<h3 id="その他">
<a class="header-anchor" href="#%e3%81%9d%e3%81%ae%e4%bb%96"></a>
その他
</h3><p>以下の関数は出力/オープンドレインモードで使用可能：</p>
<ul>
<li><code>Pin.low(),Pin.off()</code> ポートを低電圧に設定</li>
<li><code>Pin.high(),Pin.on()</code> ポートを高電圧に設定</li>
</ul>
<h3 id="例-led制御">
<a class="header-anchor" href="#%e4%be%8b-led%e5%88%b6%e5%be%a1"></a>
例. LED制御
</h3><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">machine</span> <span class="kn">import</span> <span class="n">Pin</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">utime</span>
</span></span><span class="line"><span class="cl"><span class="c1">#ボタンをGPIO15に接続、入力モード、内部プルアップ</span>
</span></span><span class="line"><span class="cl"><span class="n">button_num</span><span class="o">=</span><span class="mi">15</span>
</span></span><span class="line"><span class="cl"><span class="n">button</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="n">button_num</span><span class="p">,</span><span class="n">Pin</span><span class="o">.</span><span class="n">IN</span><span class="p">,</span><span class="n">Pin</span><span class="o">.</span><span class="n">PULL_UP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">#GP25はボード上のLED、外部LEDはGP16に接続</span>
</span></span><span class="line"><span class="cl"><span class="n">led1_num</span><span class="o">=</span><span class="mi">25</span>
</span></span><span class="line"><span class="cl"><span class="n">led2_num</span><span class="o">=</span><span class="mi">16</span>
</span></span><span class="line"><span class="cl"><span class="n">led1</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="n">led1_num</span><span class="p">,</span><span class="n">Pin</span><span class="o">.</span><span class="n">OUT</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">led2</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="n">led2_num</span><span class="p">,</span><span class="n">Pin</span><span class="o">.</span><span class="n">OUT</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="kc">True</span> <span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">led2</span><span class="o">.</span><span class="n">off</span><span class="p">()</span><span class="c1">#外部LEDをオフ</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">button</span><span class="o">.</span><span class="n">value</span><span class="p">()</span><span class="o">==</span><span class="mi">0</span><span class="p">):</span><span class="c1">#ボタンが押されたか判定（押下時0）</span>
</span></span><span class="line"><span class="cl">        <span class="n">utime</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">button</span><span class="o">.</span><span class="n">value</span><span class="p">()</span><span class="o">==</span><span class="mi">0</span><span class="p">):</span><span class="c1">#ソフトウェアデバウンス</span>
</span></span><span class="line"><span class="cl">            <span class="n">led1</span><span class="o">.</span><span class="n">toggle</span><span class="p">()</span><span class="c1">#ボード上のLEDを反転</span>
</span></span><span class="line"><span class="cl">            <span class="n">led2</span><span class="o">.</span><span class="n">on</span><span class="p">()</span><span class="c1">#外部LEDを点灯（GP16高電位）</span>
</span></span><span class="line"><span class="cl">            <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;The button is pressed.&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">while</span> <span class="p">(</span><span class="n">button</span><span class="o">.</span><span class="n">value</span><span class="p">()</span><span class="o">==</span><span class="mi">0</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="c1">#ボタンが押された状態で待機（外部LEDは点灯したまま）</span>
</span></span><span class="line"><span class="cl">                <span class="n">utime</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>
</span></span></code></pre></div><h2 id="pwmクラス">
<a class="header-anchor" href="#pwm%e3%82%af%e3%83%a9%e3%82%b9"></a>
PWMクラス
</h2><h3 id="machinepwmpin">
<a class="header-anchor" href="#machinepwmpin"></a>
<code>machine.PWM(pin)</code>
</h3><p>指定GPIOをPWM出力として再初期化
pinはPinクラスオブジェクト</p>
<h3 id="pwmdeinit">
<a class="header-anchor" href="#pwmdeinit"></a>
<code>PWM.deinit()</code>
</h3><p>PWMの初期化解除、PWM出力を停止</p>
<h3 id="pwmfreqvalue">
<a class="header-anchor" href="#pwmfreqvalue"></a>
<code>PWM.freq([value])</code>
</h3><p>PWM周波数を設定（単位$Hz$）、分周器パラメータとTOPレジスタパラメータを自動計算</p>
<h3 id="pwmduty_u16value">
<a class="header-anchor" href="#pwmduty_u16value"></a>
`PWM.duty_u16([value])
</h3><p>デューティ比を設定
valueのデューティ比範囲は[0,65536]、これに基づいてCCレジスタに値を設定</p>
<h3 id="pwmduty_nsvalue">
<a class="header-anchor" href="#pwmduty_nsvalue"></a>
<code>PWM.duty_ns([value])</code>
</h3><p>1周期の高電位時間をナノ秒単位で設定</p>
<h3 id="例-ブレスled">
<a class="header-anchor" href="#%e4%be%8b-%e3%83%96%e3%83%ac%e3%82%b9led"></a>
例. ブレスLED
</h3><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">machine</span> <span class="kn">import</span> <span class="n">Pin</span><span class="p">,</span><span class="n">PWM</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">time</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">led</span><span class="o">=</span><span class="n">PWM</span><span class="p">(</span><span class="n">Pin</span><span class="p">(</span><span class="mi">25</span><span class="p">))</span><span class="c1">#ボード上のLEDをPWMオブジェクトとして初期化</span>
</span></span><span class="line"><span class="cl"><span class="n">led</span><span class="o">.</span><span class="n">freq</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span><span class="c1">#周波数設定</span>
</span></span><span class="line"><span class="cl"><span class="n">led_duty</span><span class="o">=</span><span class="mi">0</span><span class="c1">#初期値</span>
</span></span><span class="line"><span class="cl"><span class="n">led_direction</span><span class="o">=</span><span class="mi">1</span><span class="c1">#ステップ幅</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">led_duty</span><span class="o">+=</span><span class="n">led_direction</span><span class="c1">#デューティ比を増加/減少</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">led_duty</span><span class="o">&gt;=</span><span class="mi">100</span><span class="p">:</span><span class="c1">#最大</span>
</span></span><span class="line"><span class="cl">        <span class="n">led_duty</span><span class="o">=</span><span class="mi">100</span>
</span></span><span class="line"><span class="cl">        <span class="n">led_direction</span><span class="o">=-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="k">elif</span> <span class="n">led_duty</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">:</span><span class="c1">#最小</span>
</span></span><span class="line"><span class="cl">        <span class="n">led_duty</span><span class="o">=</span><span class="mi">0</span>
</span></span><span class="line"><span class="cl">        <span class="n">led_direction</span><span class="o">=</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">    <span class="n">led</span><span class="o">.</span><span class="n">duty_u16</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">led_duty</span><span class="o">*</span><span class="mf">655.36</span><span class="p">))</span><span class="c1">#デューティ比値変換</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">led_duty</span><span class="o">%</span><span class="mi">5</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="n">led_duty</span><span class="p">)</span><span class="c1">#グラフ観測用</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">#周期2秒</span>
</span></span></code></pre></div><h2 id="adcクラス">
<a class="header-anchor" href="#adc%e3%82%af%e3%83%a9%e3%82%b9"></a>
ADCクラス
</h2><h3 id="machineadcid">
<a class="header-anchor" href="#machineadcid"></a>
<code>machine.ADC(id)</code>
</h3><p>ADCオブジェクトとして初期化、idはGPIOまたはADCチャンネル。Pinオブジェクト使用時はGPIOがADCをサポートしている必要あり。
0-3はPicoのGPIOチャンネル26-29、4はチップ内温度センサーチャンネル。</p>
<h3 id="adcread_u16">
<a class="header-anchor" href="#adcread_u16"></a>
<code>ADC.read_u16()</code>
</h3><p>対応チャンネルのADC値を読み取り[0,65525]の範囲で返す。</p>

        <hr><p>本文 2024-02-15 首发于 <a href='http://localhost:1313/'>孤筝の温暖小家</a>，最后修改于 2024-02-15</p><p>All website licensed under CC BY 4.0</p>]]>
      </description>
        <category>Code</category>
      
    </item>
    
    
      
    
    
    
    <item>
      <title>データ構造実機実験レポート8——クリティカルパス</title>
      <link>http://localhost:1313/ja/post/code/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E6%9C%BA%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A8%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Tue, 12 Dec 2023 15:00:26 &#43;0800</pubDate><author>lvbowen040427@163.com (孤筝)</author>
      <guid>http://localhost:1313/ja/post/code/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E6%9C%BA%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A8%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/</guid>
      <description><![CDATA[<h1>データ構造実機実験レポート8——クリティカルパス</h1><p>作者: 孤筝 (lvbowen040427@163.com)</p>
          <h2 id="a-問題分析">
<a class="header-anchor" href="#a-%e5%95%8f%e9%a1%8c%e5%88%86%e6%9e%90"></a>
a. 問題分析
</h2><p>クリティカルパス法において、プロジェクト全体の期間に影響を与える重要な活動シーケンスであるクリティカルパスを見つける必要があります。この問題を解決するために、まずプロジェクト活動を表すデータ構造 <code>Activity</code> を構築し、プロジェクトの計算と出力を処理する <code>Project</code> クラスを設計しました。</p>
<p>クリティカルパスの計算は、主に以下の2つの重要なステップに依存します：</p>
<ol>
<li>最早開始時間（ES）の計算：開始イベントからトポロジカルソートと動的計画法を用いて、各活動の最早開始時間を計算します。</li>
<li>最遅開始時間（LS）の計算：終了イベントから逆方向のトポロジカルソートと動的計画法を用いて、各活動の最遅開始時間を計算します。</li>
</ol>
<p>最早開始時間と最遅開始時間を比較することで、クリティカルパス上の活動を特定し、これらがプロジェクト全体の期間に決定的な影響を与えることを確認できます。</p>
<h2 id="b-アルゴリズム設計">
<a class="header-anchor" href="#b-%e3%82%a2%e3%83%ab%e3%82%b4%e3%83%aa%e3%82%ba%e3%83%a0%e8%a8%ad%e8%a8%88"></a>
b. アルゴリズム設計
</h2><h3 id="1-最早開始時間の計算">
<a class="header-anchor" href="#1-%e6%9c%80%e6%97%a9%e9%96%8b%e5%a7%8b%e6%99%82%e9%96%93%e3%81%ae%e8%a8%88%e7%ae%97"></a>
1. 最早開始時間の計算
</h3><p>トポロジカルソートと動的計画法を使用して最早開始時間を計算します。まず、すべての開始イベント（前置きイベントのない活動）を見つけ、これらの開始イベントからグラフを走査し、各活動の最早開始時間を更新します。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 最早開始時間の計算
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">calculateEarliestStart</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">Activity</span><span class="o">&amp;</span> <span class="nl">activity</span> <span class="p">:</span> <span class="n">activities</span><span class="p">)</span> <span class="p">{</span><span class="c1">// トポロジカルソートを走査
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">activity</span><span class="p">.</span><span class="n">next</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span><span class="c1">//あるノードの隣接リストが空の場合（開始イベント）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">activity</span><span class="p">.</span><span class="n">id</span><span class="p">);</span><span class="c1">//キューに入れる
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">earliestStart</span><span class="p">[</span><span class="n">activity</span><span class="p">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="c1">//最早開始時間を0に設定
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span><span class="c1">//キューが空でない場合
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">currentId</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span><span class="c1">//最優先イベントcurrentIdを取り出す
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">nextId</span> <span class="p">:</span> <span class="n">activities</span><span class="p">[</span><span class="n">currentId</span><span class="p">].</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span><span class="c1">//currentIdの隣接リストを走査
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">earliestStart</span><span class="p">[</span><span class="n">nextId</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">earliestStart</span><span class="p">[</span><span class="n">nextId</span><span class="p">],</span> <span class="n">earliestStart</span><span class="p">[</span><span class="n">currentId</span><span class="p">]</span> <span class="o">+</span> <span class="n">activities</span><span class="p">[</span><span class="n">currentId</span><span class="p">].</span><span class="n">duration</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// nextIdの最早開始時間==max{現在記録されている最早開始時間,前置きノードcurrentIdの最早開始時間+currentIdイベント時間}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">nextId</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="2-最遅開始時間の計算">
<a class="header-anchor" href="#2-%e6%9c%80%e9%81%85%e9%96%8b%e5%a7%8b%e6%99%82%e9%96%93%e3%81%ae%e8%a8%88%e7%ae%97"></a>
2. 最遅開始時間の計算
</h3><p>トポロジカルソートを逆方向に走査することで、最遅開始時間を計算します。終了イベントから開始し、各活動の最遅開始時間を段階的に更新します。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 最遅開始時間の計算
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">calculateLatestStart</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">latestStart</span> <span class="o">=</span> <span class="n">earliestStart</span><span class="p">;</span><span class="c1">//最遅開始時間を最早開始時間で初期化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">activities</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span><span class="c1">//最後のイベントiから逆方向に走査
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">nextId</span> <span class="p">:</span> <span class="n">activities</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">latestStart</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">latestStart</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">latestStart</span><span class="p">[</span><span class="n">nextId</span><span class="p">]</span> <span class="o">-</span> <span class="n">activities</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">duration</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 現在のイベントの最遅開始時間==min{記録されている最遅開始時間,次のイベントnextIdの最遅開始時間-現在のイベントiの所要時間}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="c-データ構造設計">
<a class="header-anchor" href="#c-%e3%83%87%e3%83%bc%e3%82%bf%e6%a7%8b%e9%80%a0%e8%a8%ad%e8%a8%88"></a>
c. データ構造設計
</h2><p>以下の2つの主要なデータ構造を使用しました：</p>
<ol>
<li><code>Activity</code> 構造体：プロジェクト内の活動を表し、活動番号、所要時間、および後続活動の情報を含みます。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// プロジェクト活動を表す構造体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">Activity</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">id</span><span class="p">;</span>      <span class="c1">// 活動番号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">duration</span><span class="p">;</span> <span class="c1">// 所要時間
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">next</span><span class="p">;</span> <span class="c1">// 後続活動
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><ol start="2">
<li><code>Project</code> クラス：プロジェクトを管理し、活動の追加、最早開始時間の計算、最遅開始時間の計算、クリティカルパスと時間情報の出力などのメソッドを含みます。</li>
</ol>
<h2 id="d-デバッグ過程">
<a class="header-anchor" href="#d-%e3%83%87%e3%83%90%e3%83%83%e3%82%b0%e9%81%8e%e7%a8%8b"></a>
d. デバッグ過程
</h2><p>デバッグ過程では、以下の点に重点を置きました：</p>
<ol>
<li>データ構造の正確性：<code>Activity</code> 構造体と <code>Project</code> クラスがプロジェクトと活動の関係を正しく表現していることを確認しました。</li>
<li>アルゴリズムの正確性：最早開始時間と最遅開始時間の計算アルゴリズムが正しいことを検証しました。</li>
<li>出力結果の正確性：出力されるクリティカルパスと時間情報が期待通りであることを確認しました。</li>
</ol>
<h2 id="e-出力結果">
<a class="header-anchor" href="#e-%e5%87%ba%e5%8a%9b%e7%b5%90%e6%9e%9c"></a>
e. 出力結果
</h2><p>プログラムを実行した結果、以下の出力が得られました：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">Critical Path</span><span class="p">:</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="m">5</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">Activity 0</span><span class="p">:</span><span class="w"> </span><span class="l">ES=0, LS=0</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">Activity 1</span><span class="p">:</span><span class="w"> </span><span class="l">ES=2, LS=2</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">Activity 2</span><span class="p">:</span><span class="w"> </span><span class="l">ES=6, LS=6</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">Activity 3</span><span class="p">:</span><span class="w"> </span><span class="l">ES=9, LS=9</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">Activity 4</span><span class="p">:</span><span class="w"> </span><span class="l">ES=14, LS=14</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">Activity 5</span><span class="p">:</span><span class="w"> </span><span class="l">ES=16, LS=16</span><span class="w">
</span></span></span></code></pre></div><p>結果から、クリティカルパス上の活動は0、1、2、3、4、5であり、各活動の最早開始時間と最遅開始時間が正しく計算されていることがわかります。これは、アルゴリズムとデータ構造設計が有効であることを示しています。</p>
<h2 id="f-ソースコード">
<a class="header-anchor" href="#f-%e3%82%bd%e3%83%bc%e3%82%b9%e3%82%b3%e3%83%bc%e3%83%89"></a>
f. ソースコード
</h2><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// プロジェクト活動を表す構造体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">Activity</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">id</span><span class="p">;</span>      <span class="c1">// 活動番号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">duration</span><span class="p">;</span> <span class="c1">// 所要時間
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">next</span><span class="p">;</span> <span class="c1">// 後続活動
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Project</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Activity</span><span class="o">&gt;</span> <span class="n">activities</span><span class="p">;</span> <span class="c1">// プロジェクト活動を格納するベクトル
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">earliestStart</span><span class="p">;</span>   <span class="c1">// 最早開始時間
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">latestStart</span><span class="p">;</span>     <span class="c1">// 最遅開始時間
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 活動の追加
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="n">addActivity</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">duration</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">activities</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">id</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">next</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 最早開始時間の計算
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="nf">calculateEarliestStart</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">Activity</span><span class="o">&amp;</span> <span class="nl">activity</span> <span class="p">:</span> <span class="n">activities</span><span class="p">)</span> <span class="p">{</span><span class="c1">// トポロジカルソートを走査
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">activity</span><span class="p">.</span><span class="n">next</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span><span class="c1">//あるノードの隣接リストが空の場合（開始イベント）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">activity</span><span class="p">.</span><span class="n">id</span><span class="p">);</span><span class="c1">//キューに入れる
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">earliestStart</span><span class="p">[</span><span class="n">activity</span><span class="p">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="c1">//最早開始時間を0に設定
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span><span class="c1">//キューが空でない場合
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="kt">int</span> <span class="n">currentId</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span><span class="c1">//最優先イベントcurrentIdを取り出す
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">nextId</span> <span class="p">:</span> <span class="n">activities</span><span class="p">[</span><span class="n">currentId</span><span class="p">].</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span><span class="c1">//currentIdの隣接リストを走査
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">earliestStart</span><span class="p">[</span><span class="n">nextId</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">earliestStart</span><span class="p">[</span><span class="n">nextId</span><span class="p">],</span> <span class="n">earliestStart</span><span class="p">[</span><span class="n">currentId</span><span class="p">]</span> <span class="o">+</span> <span class="n">activities</span><span class="p">[</span><span class="n">currentId</span><span class="p">].</span><span class="n">duration</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// nextIdの最早開始時間==max{現在記録されている最早開始時間,前置きノードcurrentIdの最早開始時間+currentIdイベント時間}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">nextId</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 最遅開始時間の計算
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="nf">calculateLatestStart</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">latestStart</span> <span class="o">=</span> <span class="n">earliestStart</span><span class="p">;</span><span class="c1">//最遅開始時間を最早開始時間で初期化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">activities</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span><span class="c1">//最後のイベントiから逆方向に走査
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">nextId</span> <span class="p">:</span> <span class="n">activities</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">latestStart</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">latestStart</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">latestStart</span><span class="p">[</span><span class="n">nextId</span><span class="p">]</span> <span class="o">-</span> <span class="n">activities</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">duration</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 現在のイベントの最遅開始時間==min{記録されている最遅開始時間,次のイベントnextIdの最遅開始時間-現在のイベントiの所要時間}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// クリティカルパスの出力
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="nf">printCriticalPath</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Critical Path: &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">Activity</span><span class="o">&amp;</span> <span class="nl">activity</span> <span class="p">:</span> <span class="n">activities</span><span class="p">)</span> <span class="p">{</span><span class="c1">//トポロジカルソートを順方向に走査
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">earliestStart</span><span class="p">[</span><span class="n">activity</span><span class="p">.</span><span class="n">id</span><span class="p">]</span> <span class="o">==</span> <span class="n">latestStart</span><span class="p">[</span><span class="n">activity</span><span class="p">.</span><span class="n">id</span><span class="p">])</span> <span class="p">{</span><span class="c1">//クリティカルパス上のイベントの最早開始時間==最遅開始時間
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">activity</span><span class="p">.</span><span class="n">id</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 最早開始時間と最遅開始時間の出力
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="nf">printTimeInfo</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">Activity</span><span class="o">&amp;</span> <span class="nl">activity</span> <span class="p">:</span> <span class="n">activities</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Activity &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">activity</span><span class="p">.</span><span class="n">id</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;: ES=&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">earliestStart</span><span class="p">[</span><span class="n">activity</span><span class="p">.</span><span class="n">id</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">                 <span class="o">&lt;&lt;</span> <span class="s">&#34;, LS=&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">latestStart</span><span class="p">[</span><span class="n">activity</span><span class="p">.</span><span class="n">id</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 初期化関数の構築
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Project</span><span class="p">(</span><span class="kt">int</span> <span class="n">numActivities</span><span class="p">)</span> <span class="o">:</span> <span class="n">earliestStart</span><span class="p">(</span><span class="n">numActivities</span><span class="p">),</span> <span class="n">latestStart</span><span class="p">(</span><span class="n">numActivities</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Project</span> <span class="n">project</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span> <span class="c1">// 6つの活動を仮定
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 活動の追加、各活動のフォーマットは：活動番号、所要時間、後続活動番号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">project</span><span class="p">.</span><span class="n">addActivity</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">{</span><span class="mi">1</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="n">project</span><span class="p">.</span><span class="n">addActivity</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="p">{</span><span class="mi">2</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="n">project</span><span class="p">.</span><span class="n">addActivity</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="p">{</span><span class="mi">3</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="n">project</span><span class="p">.</span><span class="n">addActivity</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="p">{</span><span class="mi">4</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="n">project</span><span class="p">.</span><span class="n">addActivity</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">{</span><span class="mi">5</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="n">project</span><span class="p">.</span><span class="n">addActivity</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">{});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 最早開始時間と最遅開始時間の計算
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">project</span><span class="p">.</span><span class="n">calculateEarliestStart</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">project</span><span class="p">.</span><span class="n">calculateLatestStart</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// クリティカルパスと時間情報の出力
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">project</span><span class="p">.</span><span class="n">printCriticalPath</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">project</span><span class="p">.</span><span class="n">printTimeInfo</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div>
        <hr><p>本文 2023-12-12 首发于 <a href='http://localhost:1313/'>孤筝の温暖小家</a>，最后修改于 2023-12-12</p><p>All website licensed under CC BY 4.0</p>]]>
      </description>
        <category>Code</category>
      
    </item>
    
    
      
    
    
    
    <item>
      <title>データ構造実機実験レポート7——Kruskalアルゴリズムと最小全域木問題、Dijkstraアルゴリズムと重み付きグラフの最短経路問題</title>
      <link>http://localhost:1313/ja/post/code/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E6%9C%BA%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A7kruskal%E7%AE%97%E6%B3%95%E4%B8%8E%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%97%AE%E9%A2%98dijkstra%E7%AE%97%E6%B3%95%E4%B8%8E%E5%B8%A6%E6%9D%83%E5%9B%BE%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Tue, 12 Dec 2023 14:58:44 &#43;0800</pubDate><author>lvbowen040427@163.com (孤筝)</author>
      <guid>http://localhost:1313/ja/post/code/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E6%9C%BA%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A7kruskal%E7%AE%97%E6%B3%95%E4%B8%8E%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%97%AE%E9%A2%98dijkstra%E7%AE%97%E6%B3%95%E4%B8%8E%E5%B8%A6%E6%9D%83%E5%9B%BE%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</guid>
      <description><![CDATA[<h1>データ構造実機実験レポート7——Kruskalアルゴリズムと最小全域木問題、Dijkstraアルゴリズムと重み付きグラフの最短経路問題</h1><p>作者: 孤筝 (lvbowen040427@163.com)</p>
          <h1 id="kruskalアルゴリズムによる最小全域木の生成">
<a class="header-anchor" href="#kruskal%e3%82%a2%e3%83%ab%e3%82%b4%e3%83%aa%e3%82%ba%e3%83%a0%e3%81%ab%e3%82%88%e3%82%8b%e6%9c%80%e5%b0%8f%e5%85%a8%e5%9f%9f%e6%9c%a8%e3%81%ae%e7%94%9f%e6%88%90"></a>
Kruskalアルゴリズムによる最小全域木の生成
</h1><h2 id="a-問題分析">
<a class="header-anchor" href="#a-%e5%95%8f%e9%a1%8c%e5%88%86%e6%9e%90"></a>
a 問題分析
</h2><p>10個のノードと20本のエッジを含むグラフの最小全域木を見つけるために、Kruskalアルゴリズムを使用する必要があります。Kruskalアルゴリズムは貪欲法に基づいており、重みが最小のエッジを選択し続け、そのエッジを追加してもループが形成されないことを確認することで、最小全域木を構築します。</p>
<h2 id="b-アルゴリズム設計">
<a class="header-anchor" href="#b-%e3%82%a2%e3%83%ab%e3%82%b4%e3%83%aa%e3%82%ba%e3%83%a0%e8%a8%ad%e8%a8%88"></a>
b アルゴリズム設計
</h2><h3 id="kruskal-アルゴリズムの主要なステップ">
<a class="header-anchor" href="#kruskal-%e3%82%a2%e3%83%ab%e3%82%b4%e3%83%aa%e3%82%ba%e3%83%a0%e3%81%ae%e4%b8%bb%e8%a6%81%e3%81%aa%e3%82%b9%e3%83%86%e3%83%83%e3%83%97"></a>
Kruskal アルゴリズムの主要なステップ：
</h3><h4 id="辺のソート">
<a class="header-anchor" href="#%e8%be%ba%e3%81%ae%e3%82%bd%e3%83%bc%e3%83%88"></a>
<strong>辺のソート：</strong>
</h4><p>すべての辺を重みの昇順でソートする。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">sort</span><span class="p">(</span><span class="n">edges</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">edges</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="k">const</span> <span class="n">Edge</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Edge</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">weight</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">weight</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span></code></pre></div><p><code>sort</code> 関数は、ソート範囲と比較ルールを指定することで、コンテナ内の要素をソートする。ここでは、辺の重みを昇順でソートするために使用され、Kruskalアルゴリズムで最小重みの辺を順に選択できるようにする。
1. <code>edges.begin()</code> と <code>edges.end()</code>: これらのパラメータはソート範囲を指定し、ソート対象要素の開始位置と終了位置を示す。ここでは、<code>edges</code> は辺の集合を格納するコンテナであり、<code>begin()</code> はコンテナの開始イテレータを返し、<code>end()</code> は終了イテレータを返す。
2. <code>[](const Edge&amp; a, const Edge&amp; b) { return a.weight &lt; b.weight; }</code>: これはラムダ式であり、ソートの比較ルールを定義する。ラムダ式は無名関数であり、ソートプロセスで2つの要素の大小を比較するために使用される。ここでは、辺の重み (<code>weight</code>) を昇順で並べ替えるための比較ルールが定義されている。
3. <code>const Edge&amp; a</code> と <code>const Edge&amp; b</code> はラムダ式のパラメータであり、比較対象の2つの辺を表す。
4. <code>return a.weight &lt; b.weight;</code> は、辺 <code>a</code> の重みが辺 <code>b</code> の重みより小さい場合に <code>true</code> を返し、それ以外の場合に <code>false</code> を返すことを意味する。これにより、<code>sort</code> 関数は辺を昇順でソートする。</p>
<h4 id="union-findの初期化">
<a class="header-anchor" href="#union-find%e3%81%ae%e5%88%9d%e6%9c%9f%e5%8c%96"></a>
<strong>Union-Findの初期化：</strong>
</h4><p>Union-Findを初期化し、各ノードを単独の集合とする。</p>
<ul>
<li>Union-Find（Disjoint Set Union、略してUnion-Find）は、集合を扱うためのデータ構造であり、主に2つの操作をサポートする：Find（検索）とUnion（結合）。このデータ構造は、集合の分割に関連する問題、特にグラフ理論やネットワーク接続などの分野で使用される。</li>
<li><strong>基本操作:</strong>
<ol>
<li><strong>Find（検索）:</strong> 要素が属する集合を検索し、通常はルートノードを見つけることで要素が属する集合を特定する。このプロセスにより、2つの要素が同じ集合に属しているかどうかを判断できる。</li>
<li><strong>Union（結合）:</strong> 2つの集合を1つの新しい集合に結合する。この操作では、通常、2つの集合のルートノードを接続し、それらが同じ集合になるようにする。</li>
</ol>
</li>
<li><strong>実装の詳細:</strong>
<ul>
<li>通常、Union-Findは配列を使用して実装される。配列の各要素は集合内の1つの要素を表し、配列の値はその要素の親ノード（またはルートノード）を示す。初期状態では、各要素は自身のルートノードである。</li>
</ul>
</li>
<li>Union-Findの性能を最適化するために、通常は経路圧縮（Path Compression）とランクによる結合（Union by Rank）という2つの技術が使用される：
<ul>
<li><strong>経路圧縮（Path Compression）:</strong> Find操作中に、検索パス上のすべてのノードの親ノードを直接ルートノードに設定することで、木の高さを低くし、以降のFind操作の効率を向上させる。</li>
<li><strong>ランクによる結合（Union by Rank）:</strong> Union操作中に、より低い木をより高い木に結合することで、木の過度な成長を防ぎ、効率を向上させる。&ldquo;ランク&quot;は通常、木の高さまたはノードの深さを指す。</li>
</ul>
</li>
</ul>
<h4 id="辺の走査">
<a class="header-anchor" href="#%e8%be%ba%e3%81%ae%e8%b5%b0%e6%9f%bb"></a>
<strong>辺の走査：</strong>
</h4><p>ソートされた辺を走査し、順番に辺を選択して最小全域木に追加し、ループが形成されないようにする。</p>
<h3 id="具体的な実装">
<a class="header-anchor" href="#%e5%85%b7%e4%bd%93%e7%9a%84%e3%81%aa%e5%ae%9f%e8%a3%85"></a>
具体的な実装：
</h3><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// Kruskalアルゴリズム
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="n">kruskal</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;&amp;</span> <span class="n">edges</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numNodes</span><span class="p">)</span> <span class="p">{</span><span class="c1">//辺集合とノード数を引数として受け取る
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 辺を重みの昇順でソート
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">sort</span><span class="p">(</span><span class="n">edges</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">edges</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="k">const</span> <span class="n">Edge</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Edge</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="c1">//比較開始辺、比較終了辺、ラムダ式（比較対象の2要素）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">weight</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">weight</span><span class="p">;</span><span class="c1">//比較ルール：辺の重みを昇順でソート
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Union-Findの初期化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">UnionFind</span> <span class="nf">uf</span><span class="p">(</span><span class="n">numNodes</span><span class="p">);</span><span class="c1">//UnionFind(サイズ)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 最小全域木の辺を格納
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ソートされた辺を走査
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">Edge</span><span class="o">&amp;</span> <span class="nl">edge</span> <span class="p">:</span> <span class="n">edges</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// この辺を追加するとループが形成されるかどうかをチェック
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">uf</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">start</span><span class="p">)</span> <span class="o">!=</span> <span class="n">uf</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">end</span><span class="p">))</span> <span class="p">{</span><span class="c1">//この辺の開始ノードと終了ノードが異なる集合（サブツリー）に属している場合
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// ループが形成されないため、最小全域木に追加
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">edge</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">uf</span><span class="p">.</span><span class="n">unite</span><span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">start</span><span class="p">,</span> <span class="n">edge</span><span class="p">.</span><span class="n">end</span><span class="p">);</span><span class="c1">//2つのノードのサブツリーを結合（同じ集合としてマーク）し、ループ形成を防止
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="c-データ構造設計">
<a class="header-anchor" href="#c-%e3%83%87%e3%83%bc%e3%82%bf%e6%a7%8b%e9%80%a0%e8%a8%ad%e8%a8%88"></a>
c データ構造設計
</h2><h3 id="1-edge-構造体">
<a class="header-anchor" href="#1-edge-%e6%a7%8b%e9%80%a0%e4%bd%93"></a>
1. <strong>Edge 構造体：</strong>
</h3><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 辺の構造体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">Edge</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">weight</span><span class="p">;</span><span class="c1">//辺の開始ノード、終了ノード、重み
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><ul>
<li><code>Edge</code> 構造体はグラフ内の1つの辺を表し、始点、終点、重みを含む。</li>
</ul>
<h3 id="2-unionfind-クラス">
<a class="header-anchor" href="#2-unionfind-%e3%82%af%e3%83%a9%e3%82%b9"></a>
2. <strong>UnionFind クラス：</strong>
</h3><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 素集合データ構造の実装
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">UnionFind</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">UnionFind</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="o">:</span> <span class="n">parent</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="n">rank</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">//parentは各ノードのルートノードを格納し、初期値は自身。rankは各ノードがルートノード時の木の深さを記録し、初期値は0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span><span class="c1">//ルートノードを自身に初期化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span><span class="c1">//ルートノードを検索
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="p">{</span><span class="c1">//xのルートノードが自身でない場合（親ノードが存在）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]);</span><span class="c1">//ルートノードを親ノードのルートノードに設定
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">];</span><span class="c1">//親ノード/上位ノードを返す
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">unite</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span><span class="c1">//2つの部分木を結合
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">rootX</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="c1">//xノードのルートノード
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">rootY</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">y</span><span class="p">);</span><span class="c1">//yノードのルートノード
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">rootX</span> <span class="o">!=</span> <span class="n">rootY</span><span class="p">)</span> <span class="p">{</span><span class="c1">//x、yが同一集合（部分木）にない場合
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">rank</span><span class="p">[</span><span class="n">rootX</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">rank</span><span class="p">[</span><span class="n">rootY</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">//xの部分木の深さがyの部分木より浅い場合
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">parent</span><span class="p">[</span><span class="n">rootX</span><span class="p">]</span> <span class="o">=</span> <span class="n">rootY</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                        <span class="c1">//xの部分木をyの部分木に統合し、結合後の深さが増加しないようにする
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rank</span><span class="p">[</span><span class="n">rootX</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">rank</span><span class="p">[</span><span class="n">rootY</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">parent</span><span class="p">[</span><span class="n">rootY</span><span class="p">]</span> <span class="o">=</span> <span class="n">rootX</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span><span class="c1">//x、yの部分木の深さが同じ場合
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">parent</span><span class="p">[</span><span class="n">rootX</span><span class="p">]</span> <span class="o">=</span> <span class="n">rootY</span><span class="p">;</span><span class="c1">//xの部分木をyの部分木に統合
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">rank</span><span class="p">[</span><span class="n">rootY</span><span class="p">]</span><span class="o">++</span><span class="p">;</span><span class="c1">//結合後の深さを++
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">parent</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">rank</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><ul>
<li><code>UnionFind</code> クラスは素集合データ構造を実装し、ノードが属する集合の検索と2つの集合の結合に使用される。<code>find</code> 関数はルートノードを検索し、<code>unite</code> 関数は2つの集合を結合する。</li>
<li>コンストラクタでは、<code>rank</code> 配列の初期値はすべて0に設定される。ここで、<code>rank</code> 配列の値はノードの深さではなく、木の高さを近似したものである。各ノードは初期状態で自身のみを含む木と見なされるため、初期高さは0である。</li>
<li><code>rank</code> 配列では、各要素の値は木の近似高さを表す。結合操作を行う際に、2つの木の高さを比較し、より低い木を高い木に接続することで、木のバランスを保つ。これにより、木の高さが過度に増加するのを防ぎ、素集合データ構造の効率性を維持する。</li>
</ul>
<h2 id="d-デバッグプロセス">
<a class="header-anchor" href="#d-%e3%83%87%e3%83%90%e3%83%83%e3%82%b0%e3%83%97%e3%83%ad%e3%82%bb%e3%82%b9"></a>
d デバッグプロセス
</h2><p>デバッグプロセスでは、コードをステップごとに実行し、各ステップの出力、特にソート後の辺、最小全域木の構築プロセス、およびUnion-Findデータ構造の状態を観察できます。中間結果を出力することで、アルゴリズムが期待通りに動作しているかどうかを検証できます。</p>
<h2 id="e-出力結果">
<a class="header-anchor" href="#e-%e5%87%ba%e5%8a%9b%e7%b5%90%e6%9e%9c"></a>
e 出力結果
</h2><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="nl">Graph</span><span class="p">:</span>
</span></span><span class="line"><span class="cl"><span class="mi">0</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">4</span>
</span></span><span class="line"><span class="cl"><span class="mi">0</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">:</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">:</span> <span class="mi">8</span>
</span></span><span class="line"><span class="cl"><span class="mi">2</span> <span class="o">-</span> <span class="mi">5</span> <span class="o">:</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="mi">2</span> <span class="o">-</span> <span class="mi">6</span> <span class="o">:</span> <span class="mi">7</span>
</span></span><span class="line"><span class="cl"><span class="mi">3</span> <span class="o">-</span> <span class="mi">7</span> <span class="o">:</span> <span class="mi">5</span>
</span></span><span class="line"><span class="cl"><span class="mi">3</span> <span class="o">-</span> <span class="mi">8</span> <span class="o">:</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="mi">4</span> <span class="o">-</span> <span class="mi">9</span> <span class="o">:</span> <span class="mi">6</span>
</span></span><span class="line"><span class="cl"><span class="mi">5</span> <span class="o">-</span> <span class="mi">6</span> <span class="o">:</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="mi">6</span> <span class="o">-</span> <span class="mi">8</span> <span class="o">:</span> <span class="mi">6</span>
</span></span><span class="line"><span class="cl"><span class="mi">7</span> <span class="o">-</span> <span class="mi">9</span> <span class="o">:</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="mi">8</span> <span class="o">-</span> <span class="mi">9</span> <span class="o">:</span> <span class="mi">9</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="mi">3</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">:</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="mi">5</span> <span class="o">-</span> <span class="mi">7</span> <span class="o">:</span> <span class="mi">4</span>
</span></span><span class="line"><span class="cl"><span class="mi">6</span> <span class="o">-</span> <span class="mi">9</span> <span class="o">:</span> <span class="mi">7</span>
</span></span><span class="line"><span class="cl"><span class="mi">0</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">:</span> <span class="mi">6</span>
</span></span><span class="line"><span class="cl"><span class="mi">2</span> <span class="o">-</span> <span class="mi">8</span> <span class="o">:</span> <span class="mi">5</span>
</span></span><span class="line"><span class="cl"><span class="mi">4</span> <span class="o">-</span> <span class="mi">5</span> <span class="o">:</span> <span class="mi">4</span>
</span></span><span class="line"><span class="cl"><span class="err">最小全域木の辺</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"><span class="mi">0</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="mi">3</span> <span class="o">-</span> <span class="mi">8</span> <span class="o">:</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">:</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="mi">5</span> <span class="o">-</span> <span class="mi">6</span> <span class="o">:</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="mi">2</span> <span class="o">-</span> <span class="mi">5</span> <span class="o">:</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="mi">3</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">:</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="mi">7</span> <span class="o">-</span> <span class="mi">9</span> <span class="o">:</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="mi">5</span> <span class="o">-</span> <span class="mi">7</span> <span class="o">:</span> <span class="mi">4</span>
</span></span></code></pre></div><h2 id="f-ソースコード">
<a class="header-anchor" href="#f-%e3%82%bd%e3%83%bc%e3%82%b9%e3%82%b3%e3%83%bc%e3%83%89"></a>
f ソースコード
</h2><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="c1">//sort関数を呼び出す
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 辺の構造体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">Edge</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">weight</span><span class="p">;</span><span class="c1">//辺の開始ノード、終了ノード、重み
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Union-Findの実装
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">UnionFind</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">UnionFind</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="o">:</span> <span class="n">parent</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="n">rank</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">//parentは各ノードのルートノードを格納し、初期値は自身。rankは各ノードがルートノード時の木の深さを記録し、初期値は0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span><span class="c1">//ルートノードを自身に初期化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span><span class="c1">//ルートノードを検索
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="p">{</span><span class="c1">//xのルートノードが自身でない場合（親ノードが存在）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]);</span><span class="c1">//ルートノードを親ノードのルートノードに設定
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">];</span><span class="c1">//親ノード/上位ノードを返す
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">unite</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span><span class="c1">//2つの部分木を結合
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">rootX</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="c1">//xノードのルートノード
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">rootY</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">y</span><span class="p">);</span><span class="c1">//yノードのルートノード
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">rootX</span> <span class="o">!=</span> <span class="n">rootY</span><span class="p">)</span> <span class="p">{</span><span class="c1">//x、yが同一集合（部分木）にない場合
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">rank</span><span class="p">[</span><span class="n">rootX</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">rank</span><span class="p">[</span><span class="n">rootY</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">//xの部分木の深さがyの部分木の深さより小さい場合
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">parent</span><span class="p">[</span><span class="n">rootX</span><span class="p">]</span> <span class="o">=</span> <span class="n">rootY</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                        <span class="c1">//xの部分木をyの部分木に統合し、結合後の深さが増えないようにする
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rank</span><span class="p">[</span><span class="n">rootX</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">rank</span><span class="p">[</span><span class="n">rootY</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">parent</span><span class="p">[</span><span class="n">rootY</span><span class="p">]</span> <span class="o">=</span> <span class="n">rootX</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span><span class="c1">//x、yの部分木の深さが同じ場合
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">parent</span><span class="p">[</span><span class="n">rootX</span><span class="p">]</span> <span class="o">=</span> <span class="n">rootY</span><span class="p">;</span><span class="c1">//xの部分木をyの部分木に統合
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">rank</span><span class="p">[</span><span class="n">rootY</span><span class="p">]</span><span class="o">++</span><span class="p">;</span><span class="c1">//結合後の深さ++
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">parent</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">rank</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Kruskalアルゴリズム
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="n">kruskal</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;&amp;</span> <span class="n">edges</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numNodes</span><span class="p">)</span> <span class="p">{</span><span class="c1">//辺集合、ノード数を渡す
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 辺を重みの昇順でソート
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">sort</span><span class="p">(</span><span class="n">edges</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">edges</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="k">const</span> <span class="n">Edge</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Edge</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="c1">//比較開始辺、比較終了辺、lambda式（2つの比較要素）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">weight</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">weight</span><span class="p">;</span><span class="c1">//比較ルール：辺の重みの昇順ソート
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Union-Findを初期化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">UnionFind</span> <span class="nf">uf</span><span class="p">(</span><span class="n">numNodes</span><span class="p">);</span><span class="c1">//UnionFind(size)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 最小全域木の辺を格納
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ソート後の辺を走査
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">Edge</span><span class="o">&amp;</span> <span class="nl">edge</span> <span class="p">:</span> <span class="n">edges</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// この辺を追加するとループが形成されるかどうかをチェック
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">uf</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">start</span><span class="p">)</span> <span class="o">!=</span> <span class="n">uf</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">end</span><span class="p">))</span> <span class="p">{</span><span class="c1">//この辺の開始ノードと終了ノードが同一集合（部分木）にない場合
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// ループが形成されないため、最小全域木に追加
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">edge</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">uf</span><span class="p">.</span><span class="n">unite</span><span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">start</span><span class="p">,</span> <span class="n">edge</span><span class="p">.</span><span class="n">end</span><span class="p">);</span><span class="c1">//2つのノードの部分木を結合（同一集合としてマーク）し、ループ形成を防止
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 10ノードのグラフを作成
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">numNodes</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 辺集合を作成し、辺の始点、終点、重みを手動で設定
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="n">edges</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">6</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">7</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">5</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//グラフを出力
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Graph:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">Edge</span><span class="o">&amp;</span> <span class="nl">edge</span> <span class="p">:</span> <span class="n">edges</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">edge</span><span class="p">.</span><span class="n">start</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; - &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">edge</span><span class="p">.</span><span class="n">end</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; : &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">edge</span><span class="p">.</span><span class="n">weight</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Kruskalアルゴリズムを実行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="n">minSpanningTree</span> <span class="o">=</span> <span class="n">kruskal</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">numNodes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 最小全域木の辺を出力
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Edges in the minimum spanning tree:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">Edge</span><span class="o">&amp;</span> <span class="nl">edge</span> <span class="p">:</span> <span class="n">minSpanningTree</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">edge</span><span class="p">.</span><span class="n">start</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; - &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">edge</span><span class="p">.</span><span class="n">end</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; : &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">edge</span><span class="p">.</span><span class="n">weight</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h1 id="dijkstraアルゴリズムによる重み付きグラフの最短経路問題解決">
<a class="header-anchor" href="#dijkstra%e3%82%a2%e3%83%ab%e3%82%b4%e3%83%aa%e3%82%ba%e3%83%a0%e3%81%ab%e3%82%88%e3%82%8b%e9%87%8d%e3%81%bf%e4%bb%98%e3%81%8d%e3%82%b0%e3%83%a9%e3%83%95%e3%81%ae%e6%9c%80%e7%9f%ad%e7%b5%8c%e8%b7%af%e5%95%8f%e9%a1%8c%e8%a7%a3%e6%b1%ba"></a>
Dijkstraアルゴリズムによる重み付きグラフの最短経路問題解決
</h1><h2 id="a-問題分析-1">
<a class="header-anchor" href="#a-%e5%95%8f%e9%a1%8c%e5%88%86%e6%9e%90-1"></a>
a 問題分析
</h2><p>コードは Dijkstra アルゴリズムを実装しており、重み付きグラフにおける単一始点最短経路問題を解決します。与えられた隣接行列でグラフを表現し、指定された開始ノードから、その開始ノードからグラフ内の他のすべてのノードへの最短距離を計算します。</p>
<h2 id="b-アルゴリズム設計-1">
<a class="header-anchor" href="#b-%e3%82%a2%e3%83%ab%e3%82%b4%e3%83%aa%e3%82%ba%e3%83%a0%e8%a8%ad%e8%a8%88-1"></a>
b アルゴリズム設計
</h2><h3 id="1-初期化">
<a class="header-anchor" href="#1-%e5%88%9d%e6%9c%9f%e5%8c%96"></a>
1. 初期化
</h3><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">graph</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">distances</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">INF</span><span class="p">);</span>
</span></span></code></pre></div><ul>
<li><strong>分析：</strong> グラフのノード数 <code>n</code> を取得し、距離配列 <code>distances</code> を初期化します。すべてのノードの距離初期値を無限大（<code>INF</code>）に設定します。</li>
</ul>
<h3 id="2-優先度付きキューを構築">
<a class="header-anchor" href="#2-%e5%84%aa%e5%85%88%e5%ba%a6%e4%bb%98%e3%81%8d%e3%82%ad%e3%83%a5%e3%83%bc%e3%82%92%e6%a7%8b%e7%af%89"></a>
2. 優先度付きキューを構築
</h3><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="n">greater</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;&gt;</span> <span class="n">pq</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">distances</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">pq</span><span class="p">.</span><span class="n">push</span><span class="p">({</span><span class="mi">0</span><span class="p">,</span> <span class="n">start</span><span class="p">});</span>
</span></span></code></pre></div><ul>
<li><strong>分析：</strong> 優先度付きキュー <code>pq</code> を作成します。要素はノードとその距離の <code>pair</code> です。開始ノードの距離を0に設定し、そのノードを優先度付きキューに追加します。</li>
</ul>
<h3 id="3-ループ処理">
<a class="header-anchor" href="#3-%e3%83%ab%e3%83%bc%e3%83%97%e5%87%a6%e7%90%86"></a>
3. ループ処理
</h3><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">pq</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">pq</span><span class="p">.</span><span class="n">top</span><span class="p">().</span><span class="n">second</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">pq</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">distances</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">distances</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">distances</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="n">pq</span><span class="p">.</span><span class="n">push</span><span class="p">({</span><span class="n">distances</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">v</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li><strong>分析：</strong> 優先度付きキューから現在の起点からの距離が最小のノード <code>u</code> を取り出し、ノード <code>u</code> の隣接ノードを走査します。ノード <code>u</code> を経由して隣接ノード <code>v</code> に到達する距離が既知の距離よりも短い場合、距離値を更新し、新しい距離とノード <code>v</code> をキューに追加します。</li>
</ul>
<h3 id="4-繰り返し">
<a class="header-anchor" href="#4-%e7%b9%b0%e3%82%8a%e8%bf%94%e3%81%97"></a>
4. 繰り返し
</h3><ul>
<li><strong>分析：</strong> ステップ3を優先度付きキューが空になるまで繰り返します。各ステップで、キュー内のノードは現在の起点からの距離が最小であることが保証され、常に既知の最短経路のノードを拡張するように選択されます。</li>
</ul>
<h2 id="c-データ構造設計-1">
<a class="header-anchor" href="#c-%e3%83%87%e3%83%bc%e3%82%bf%e6%a7%8b%e9%80%a0%e8%a8%ad%e8%a8%88-1"></a>
c データ構造設計
</h2><h3 id="1-graphグラフの隣接行列表現">
<a class="header-anchor" href="#1-graph%e3%82%b0%e3%83%a9%e3%83%95%e3%81%ae%e9%9a%a3%e6%8e%a5%e8%a1%8c%e5%88%97%e8%a1%a8%e7%8f%be"></a>
1. Graph（グラフの隣接行列表現）
</h3><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">Graph</span><span class="p">;</span>
</span></span></code></pre></div><ul>
<li><strong>分析：</strong> <code>Graph</code> は二次元ベクトルで、グラフの隣接行列を表します。<code>graph[u][v]</code> はノード <code>u</code> からノード <code>v</code> への辺の重みを示します。0 は直接接続がないことを意味します。</li>
</ul>
<h3 id="2-distancesノードから開始ノードまでの最短距離を格納">
<a class="header-anchor" href="#2-distances%e3%83%8e%e3%83%bc%e3%83%89%e3%81%8b%e3%82%89%e9%96%8b%e5%a7%8b%e3%83%8e%e3%83%bc%e3%83%89%e3%81%be%e3%81%a7%e3%81%ae%e6%9c%80%e7%9f%ad%e8%b7%9d%e9%9b%a2%e3%82%92%e6%a0%bc%e7%b4%8d"></a>
2. distances（ノードから開始ノードまでの最短距離を格納）
</h3><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">distances</span><span class="p">;</span>
</span></span></code></pre></div><ul>
<li><strong>分析：</strong> <code>distances</code> は一次元ベクトルで、各ノードから開始ノードまでの最短距離を格納するために使用されます。初期値は無限大で、Dijkstraアルゴリズムの実行過程で更新されます。</li>
</ul>
<h3 id="3-pq優先度付きキュー">
<a class="header-anchor" href="#3-pq%e5%84%aa%e5%85%88%e5%ba%a6%e4%bb%98%e3%81%8d%e3%82%ad%e3%83%a5%e3%83%bc"></a>
3. pq（優先度付きキュー）
</h3><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="n">greater</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;&gt;</span> <span class="n">pq</span><span class="p">;</span>
</span></span></code></pre></div><ul>
<li><strong>分析：</strong> <code>pq</code> は優先度付きキューで、ノードの距離が小さい順に並べ替えるために使用されます。各キュー要素は <code>pair&lt;int, int&gt;</code> で、ノードとその距離を表します。<code>greater&lt;pair&lt;int, int&gt;&gt;</code> で比較ルールを指定し、先頭要素が最小になるようにします。</li>
</ul>
<h2 id="d-デバッグプロセス-1">
<a class="header-anchor" href="#d-%e3%83%87%e3%83%90%e3%83%83%e3%82%b0%e3%83%97%e3%83%ad%e3%82%bb%e3%82%b9-1"></a>
d デバッグプロセス
</h2><ul>
<li><code>dijkstra</code> 関数内で <code>cout</code> を使用して中間結果を出力し、各ステップの計算が期待通りであることを確認します。</li>
<li>グラフに辺がない場合や負の重みの辺がある場合などの境界条件を考慮し、アルゴリズムの堅牢性を確保します。</li>
<li>複数のテストケースを使用してアルゴリズムの正確性と効率を検証します。</li>
</ul>
<h2 id="e-出力結果-1">
<a class="header-anchor" href="#e-%e5%87%ba%e5%8a%9b%e7%b5%90%e6%9e%9c-1"></a>
e 出力結果
</h2><p>最終的に各ノードから開始ノードまでの最短距離が出力され、結果は予想通りであり、アルゴリズムが最短経路を正しく計算できたことを示しています。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">Distance</span> <span class="n">from</span> <span class="n">node</span> <span class="mi">0</span> <span class="n">to</span> <span class="mi">0</span><span class="o">:</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="n">Distance</span> <span class="n">from</span> <span class="n">node</span> <span class="mi">0</span> <span class="n">to</span> <span class="mi">1</span><span class="o">:</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="n">Distance</span> <span class="n">from</span> <span class="n">node</span> <span class="mi">0</span> <span class="n">to</span> <span class="mi">2</span><span class="o">:</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="n">Distance</span> <span class="n">from</span> <span class="n">node</span> <span class="mi">0</span> <span class="n">to</span> <span class="mi">3</span><span class="o">:</span> <span class="mi">9</span>
</span></span><span class="line"><span class="cl"><span class="n">Distance</span> <span class="n">from</span> <span class="n">node</span> <span class="mi">0</span> <span class="n">to</span> <span class="mi">4</span><span class="o">:</span> <span class="mi">6</span>
</span></span></code></pre></div><h2 id="f-ソースコード-1">
<a class="header-anchor" href="#f-%e3%82%bd%e3%83%bc%e3%82%b9%e3%82%b3%e3%83%bc%e3%83%89-1"></a>
f ソースコード
</h2><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;queue&gt;</span><span class="c1">//優先度付きキューを導入
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;climits&gt;</span><span class="c1">//int型の最大値を導入
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#define INF INT_MAX
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// グラフの隣接行列表現を定義
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">Graph</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">//二次元ベクトルでノード間の辺の重みを表現、graph[u][v]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// Dijkstraアルゴリズムの実装
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">dijkstra</span><span class="p">(</span><span class="k">const</span> <span class="n">Graph</span><span class="o">&amp;</span> <span class="n">graph</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">distances</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">//グラフ、開始ノード、開始ノードから各ノードへの距離配列を渡す
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">graph</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="c1">//nはノード数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">distances</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">INF</span><span class="p">);</span>  <span class="c1">// 距離配列を初期化、初期値は無限大
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 優先度付きキュー、距離の小さい順に並べる
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="n">greater</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;&gt;</span> <span class="n">pq</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">//pairは他のノードと、そのノードから開始ノードまでの距離で構成されるペア{distance,v}
</span></span></span><span class="line"><span class="cl"><span class="c1">//優先度キューの要素型はpair、基盤となるコンテナ型はvector
</span></span></span><span class="line"><span class="cl"><span class="c1">//比較関数greaterを定義、pairを比較し、キューの先頭は距離が最短のノードペアとなる
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="n">distances</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 開始ノードから自身への距離は0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">pq</span><span class="p">.</span><span class="n">push</span><span class="p">({</span><span class="mi">0</span><span class="p">,</span> <span class="n">start</span><span class="p">});</span>   <span class="c1">// 開始ノードをキューに追加、距離は0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">pq</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">pq</span><span class="p">.</span><span class="n">top</span><span class="p">().</span><span class="n">second</span><span class="p">;</span>  <span class="c1">// 現在の起点から最短距離にあるノードを取り出し、出発点uとする
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">pq</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">v</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">distances</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">distances</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 現在のノードu経由でノードvに至る距離が既知の距離より短い場合、距離値を更新
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">distances</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="n">pq</span><span class="p">.</span><span class="n">push</span><span class="p">({</span><span class="n">distances</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">v</span><span class="p">});</span>  <span class="c1">// 新しい距離とノードvをキューに追加
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// サンプルグラフの隣接行列表現
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Graph</span> <span class="n">graph</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">startNode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">distances</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">dijkstra</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">startNode</span><span class="p">,</span> <span class="n">distances</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 各ノードから開始ノードへの最短距離を出力
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">distances</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Distance from node &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">startNode</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; to &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;: &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">distances</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">INF</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;INF&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">distances</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div>
        <hr><p>本文 2023-12-12 首发于 <a href='http://localhost:1313/'>孤筝の温暖小家</a>，最后修改于 2023-12-12</p><p>All website licensed under CC BY 4.0</p>]]>
      </description>
        <category>Code</category>
      
    </item>
    
    
      
    
    
    
    <item>
      <title>データ構造実機実験レポート6——前順序・後順序による二分木のスレッド化、グラフの隣接行列と隣接リストの格納</title>
      <link>http://localhost:1313/ja/post/code/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E6%9C%BA%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A6%E5%89%8D%E5%BA%8F%E5%90%8E%E7%BB%AD%E5%B0%86%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BA%BF%E7%B4%A2%E5%8C%96%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%92%8C%E9%82%BB%E6%8E%A5%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8/</link>
      <pubDate>Tue, 12 Dec 2023 14:56:33 &#43;0800</pubDate><author>lvbowen040427@163.com (孤筝)</author>
      <guid>http://localhost:1313/ja/post/code/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E6%9C%BA%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A6%E5%89%8D%E5%BA%8F%E5%90%8E%E7%BB%AD%E5%B0%86%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BA%BF%E7%B4%A2%E5%8C%96%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%92%8C%E9%82%BB%E6%8E%A5%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8/</guid>
      <description><![CDATA[<h1>データ構造実機実験レポート6——前順序・後順序による二分木のスレッド化、グラフの隣接行列と隣接リストの格納</h1><p>作者: 孤筝 (lvbowen040427@163.com)</p>
          <h1 id="前順序後順序による二分木のスレッド化">
<a class="header-anchor" href="#%e5%89%8d%e9%a0%86%e5%ba%8f%e5%be%8c%e9%a0%86%e5%ba%8f%e3%81%ab%e3%82%88%e3%82%8b%e4%ba%8c%e5%88%86%e6%9c%a8%e3%81%ae%e3%82%b9%e3%83%ac%e3%83%83%e3%83%89%e5%8c%96"></a>
前順序、後順序による二分木のスレッド化
</h1><h2 id="a-問題分析">
<a class="header-anchor" href="#a-%e5%95%8f%e9%a1%8c%e5%88%86%e6%9e%90"></a>
a. 問題分析
</h2><p>二分木の前順序スレッディングを実装する必要があります。スレッディングとは、二分リンクリストの空ポインタ領域を、特定の走査順序における前駆ノードまたは後続ノードを指すように変更する方法です。これにより、前順序、中順序、または後順序のいずれかのノードから開始することができ、根ノードからだけではなくなります。</p>
<h2 id="b-アルゴリズム設計">
<a class="header-anchor" href="#b-%e3%82%a2%e3%83%ab%e3%82%b4%e3%83%aa%e3%82%ba%e3%83%a0%e8%a8%ad%e8%a8%88"></a>
b. アルゴリズム設計
</h2><p>私たちのアルゴリズムはまず二分木を作成し、その後それをスレッド化します。スレッド化のプロセスは再帰関数によって実装され、この関数は各ノードを走査し、その左右の子ノードが存在するかどうかをチェックします。存在しない場合、その左/右ポインタを前/次のノードに指向させます。最後に、スレッド化が成功したかどうかを確認するため、中間順走査を行います。</p>
<p>以下はスレッド化のコードスニペットです：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// スレッドを作成する関数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">createThread</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// ノードが空の場合、直接戻る
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">createThread</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span> <span class="c1">// 左部分木を再帰的に処理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 左子ノードが空の場合、左ポインタを前のノードに指向させ、左スレッドフラグを1に設定
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">p</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">pre</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">p</span><span class="o">-&gt;</span><span class="n">ltag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">pre</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pre</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 前のノードの右子ノードが空の場合、その右ポインタを現在のノードに指向させ、右スレッドフラグを1に設定
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">pre</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">pre</span><span class="o">-&gt;</span><span class="n">rtag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">pre</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span> <span class="c1">// 前のノードを更新
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">createThread</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span> <span class="c1">// 右部分木を再帰的に処理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><h2 id="c-データ構造設計">
<a class="header-anchor" href="#c-%e3%83%87%e3%83%bc%e3%82%bf%e6%a7%8b%e9%80%a0%e8%a8%ad%e8%a8%88"></a>
c. データ構造設計
</h2><p>二分木のノードを表現するために、構造体を使用します。この構造体には、データフィールドと2つのポインタフィールドが含まれており、それぞれ左子ノードと右子ノードを指します。さらに、左右のポインタがスレッド化されているかどうかを示す2つのマークフィールドを追加しました。</p>
<p>以下はデータ構造のコードスニペットです：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 二分木ノードの構造体を定義
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">data</span><span class="p">;</span> <span class="c1">// ノードのデータ
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Node</span><span class="o">*</span> <span class="n">left</span><span class="p">;</span> <span class="c1">// 左子ノード
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Node</span><span class="o">*</span> <span class="n">right</span><span class="p">;</span> <span class="c1">// 右子ノード
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">ltag</span><span class="p">,</span> <span class="n">rtag</span><span class="p">;</span> <span class="c1">// 左右スレッドマーク
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><h2 id="d-デバッグプロセス">
<a class="header-anchor" href="#d-%e3%83%87%e3%83%90%e3%83%83%e3%82%b0%e3%83%97%e3%83%ad%e3%82%bb%e3%82%b9"></a>
d. デバッグプロセス
</h2><p>まず二分木を作成し、それをスレッド化します。その後、中順走査を行い、スレッド化が成功したかどうかを確認します。走査結果が期待通りの結果と一致すれば、スレッド化は成功したと判断できます。</p>
<p>以下はデバッグプロセスのコードスニペットです：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 二分木を作成
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Node</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">n3</span><span class="p">,</span> <span class="n">n4</span><span class="p">,</span> <span class="n">n5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">n1</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">n2</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">n3</span> <span class="o">=</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">n4</span> <span class="o">=</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">n5</span> <span class="o">=</span> <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 二分木をスレッド化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">createThread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// スレッド化された二分木を中順走査
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">inOrder</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="e-出力結果">
<a class="header-anchor" href="#e-%e5%87%ba%e5%8a%9b%e7%b5%90%e6%9e%9c"></a>
e. 出力結果
</h2><p>プログラムの出力結果は二分木の中間順走査結果であるべきです。この例では、出力結果は <code>4 2 5 1 3</code> となるはずです。作成した二分木の中間順走査結果がこのシーケンスになります。</p>
<h2 id="f-ソースコード">
<a class="header-anchor" href="#f-%e3%82%bd%e3%83%bc%e3%82%b9%e3%82%b3%e3%83%bc%e3%83%89"></a>
f. ソースコード
</h2><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include&lt;iostream&gt;
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 二分木ノードの構造体を定義
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">data</span><span class="p">;</span> <span class="c1">// ノードのデータ
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Node</span><span class="o">*</span> <span class="n">left</span><span class="p">;</span> <span class="c1">// 左子ノード
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Node</span><span class="o">*</span> <span class="n">right</span><span class="p">;</span> <span class="c1">// 右子ノード
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">ltag</span><span class="p">,</span> <span class="n">rtag</span><span class="p">;</span> <span class="c1">// 左右のスレッドマーク
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 前のノードを保存するためのグローバル変数preを定義
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Node</span><span class="o">*</span> <span class="n">pre</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// スレッドを作成する関数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">createThread</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// ノードが空の場合、直接戻る
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">createThread</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span> <span class="c1">// 左部分木を再帰的に処理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 左子ノードが空の場合、左ポインタを前のノードに指向し、左スレッドマークを1に設定
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">p</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">pre</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">p</span><span class="o">-&gt;</span><span class="n">ltag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">pre</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pre</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 前のノードの右子ノードが空の場合、その右ポインタを現在のノードに指向し、右スレッドマークを1に設定
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">pre</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">pre</span><span class="o">-&gt;</span><span class="n">rtag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">pre</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span> <span class="c1">// 前のノードを更新
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">createThread</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span> <span class="c1">// 右部分木を再帰的に処理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// スレッド二分木を中順走査する関数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">inOrder</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ltag</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 最も左のノードを見つける
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span> <span class="c1">// ノードデータを出力
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rtag</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 右ポインタがスレッドの場合、直接後続ノードにジャンプ
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span> <span class="c1">// 右部分木を処理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 二分木を作成
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Node</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">n3</span><span class="p">,</span> <span class="n">n4</span><span class="p">,</span> <span class="n">n5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">n1</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">n2</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">n3</span> <span class="o">=</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">n4</span> <span class="o">=</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">n5</span> <span class="o">=</span> <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 二分木をスレッド化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">createThread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// スレッド二分木を中順走査
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">inOrder</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h1 id="グラフの隣接行列と隣接リストの記憶">
<a class="header-anchor" href="#%e3%82%b0%e3%83%a9%e3%83%95%e3%81%ae%e9%9a%a3%e6%8e%a5%e8%a1%8c%e5%88%97%e3%81%a8%e9%9a%a3%e6%8e%a5%e3%83%aa%e3%82%b9%e3%83%88%e3%81%ae%e8%a8%98%e6%86%b6"></a>
グラフの隣接行列と隣接リストの記憶
</h1><h2 id="a-問題分析-1">
<a class="header-anchor" href="#a-%e5%95%8f%e9%a1%8c%e5%88%86%e6%9e%90-1"></a>
a. 問題分析
</h2><p>私たちの目標は、C++でグラフの隣接行列と隣接リストの保存を実装することです。これには、配列（隣接行列用）とリンクリスト（隣接リスト用）という2つの異なるデータ構造が関わってきます。</p>
<h2 id="b-アルゴリズム設計-1">
<a class="header-anchor" href="#b-%e3%82%a2%e3%83%ab%e3%82%b4%e3%83%aa%e3%82%ba%e3%83%a0%e8%a8%ad%e8%a8%88-1"></a>
b. アルゴリズム設計
</h2><h3 id="隣接行列">
<a class="header-anchor" href="#%e9%9a%a3%e6%8e%a5%e8%a1%8c%e5%88%97"></a>
隣接行列
</h3><p>二次元配列<code>adj[MAX][MAX]</code>を使用してグラフの隣接行列を格納します。各要素<code>adj[i][j]</code>は、ノードiからノードjへの辺が存在するかどうかを示します。存在する場合、<code>adj[i][j] = 1</code>、そうでない場合は<code>adj[i][j] = 0</code>となります。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">max_edges</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">origin</span> <span class="o">&gt;&gt;</span> <span class="n">destin</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">((</span><span class="n">origin</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">destin</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">origin</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="o">||</span> <span class="n">destin</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="o">||</span> <span class="n">origin</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">destin</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">i</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">adj</span><span class="p">[</span><span class="n">origin</span><span class="p">][</span><span class="n">destin</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="隣接リスト">
<a class="header-anchor" href="#%e9%9a%a3%e6%8e%a5%e3%83%aa%e3%82%b9%e3%83%88"></a>
隣接リスト
</h3><p>連結リストの配列<code>list&lt;int&gt; *adj</code>を使用してグラフの隣接リストを格納します。各要素<code>adj[i]</code>は、ノードiに隣接するすべてのノードを格納する連結リストです。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Graph</span><span class="o">::</span><span class="n">addEdge</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">w</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">adj</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="c-データ構造設計-1">
<a class="header-anchor" href="#c-%e3%83%87%e3%83%bc%e3%82%bf%e6%a7%8b%e9%80%a0%e8%a8%ad%e8%a8%88-1"></a>
c. データ構造設計
</h2><h3 id="隣接行列-1">
<a class="header-anchor" href="#%e9%9a%a3%e6%8e%a5%e8%a1%8c%e5%88%97-1"></a>
隣接行列
</h3><p>二次元配列<code>int adj[MAX][MAX]</code>を使用して隣接行列を格納します。<code>MAX</code>はグラフ内のノードの最大数です。</p>
<h3 id="隣接リスト-1">
<a class="header-anchor" href="#%e9%9a%a3%e6%8e%a5%e3%83%aa%e3%82%b9%e3%83%88-1"></a>
隣接リスト
</h3><p>リンクリストの配列<code>list&lt;int&gt; *adj</code>を使用して隣接リストを格納します。<code>V</code>はグラフ内のノードの数です。</p>
<h2 id="d-デバッグプロセス-1">
<a class="header-anchor" href="#d-%e3%83%87%e3%83%90%e3%83%83%e3%82%b0%e3%83%97%e3%83%ad%e3%82%bb%e3%82%b9-1"></a>
d. デバッグプロセス
</h2><p>コードの実装とデバッグの過程で、まず入力された辺が有効であることを確認しました。入力された辺が無効な場合（例えば、存在しないノードを参照している場合）、ユーザーに通知し、再入力を促します。</p>
<p>隣接行列または隣接リストに辺を追加する際には、配列やリンクリストの範囲外インデックスにアクセスしようとしないように、エラーチェックを使用しました。</p>
<h2 id="e-出力結果-1">
<a class="header-anchor" href="#e-%e5%87%ba%e5%8a%9b%e7%b5%90%e6%9e%9c-1"></a>
e. 出力結果
</h2><p>最後に、隣接行列または隣接リストを出力して、コードが正しいかどうかを確認できます。隣接リストの場合、各ノードのリンクリストを走査し、すべての隣接ノードを出力します。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Graph</span><span class="o">::</span><span class="n">printGraph</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">V</span><span class="p">;</span> <span class="n">v</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s"> Adjacency list of vertex &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">v</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s"> head &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">adj</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;-&gt; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="f-ソースコード-1">
<a class="header-anchor" href="#f-%e3%82%bd%e3%83%bc%e3%82%b9%e3%82%b3%e3%83%bc%e3%83%89-1"></a>
f. ソースコード
</h2><h3 id="隣接行列による格納">
<a class="header-anchor" href="#%e9%9a%a3%e6%8e%a5%e8%a1%8c%e5%88%97%e3%81%ab%e3%82%88%e3%82%8b%e6%a0%bc%e7%b4%8d"></a>
隣接行列による格納
</h3><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include&lt;iostream&gt;
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MAX 20
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">adj</span><span class="p">[</span><span class="n">MAX</span><span class="p">][</span><span class="n">MAX</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">create_graph</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">max_edges</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">destin</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Enter number of nodes : &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">max_edges</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">max_edges</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Enter edge &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; (-1 -1 to quit) : &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">origin</span> <span class="o">&gt;&gt;</span> <span class="n">destin</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">((</span><span class="n">origin</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">destin</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">origin</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="o">||</span> <span class="n">destin</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="o">||</span> <span class="n">origin</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">destin</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Invalid edge!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">i</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">adj</span><span class="p">[</span><span class="n">origin</span><span class="p">][</span><span class="n">destin</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="隣接リストによる格納">
<a class="header-anchor" href="#%e9%9a%a3%e6%8e%a5%e3%83%aa%e3%82%b9%e3%83%88%e3%81%ab%e3%82%88%e3%82%8b%e6%a0%bc%e7%b4%8d"></a>
隣接リストによる格納
</h3><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include&lt;iostream&gt;
</span></span></span><span class="line"><span class="cl"><span class="cp">#include&lt;list&gt;
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Graph</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">V</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">adj</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Graph</span><span class="p">(</span><span class="kt">int</span> <span class="n">V</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">addEdge</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">w</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">printGraph</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Graph</span><span class="o">::</span><span class="n">Graph</span><span class="p">(</span><span class="kt">int</span> <span class="n">V</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="o">-&gt;</span><span class="n">V</span> <span class="o">=</span> <span class="n">V</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">adj</span> <span class="o">=</span> <span class="k">new</span> <span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">[</span><span class="n">V</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Graph</span><span class="o">::</span><span class="n">addEdge</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">w</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">adj</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Graph</span><span class="o">::</span><span class="n">printGraph</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">V</span><span class="p">;</span> <span class="n">v</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s"> Adjacency list of vertex &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">v</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s"> head &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">adj</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;-&gt; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div>
        <hr><p>本文 2023-12-12 首发于 <a href='http://localhost:1313/'>孤筝の温暖小家</a>，最后修改于 2023-12-12</p><p>All website licensed under CC BY 4.0</p>]]>
      </description>
        <category>Code</category>
      
    </item>
    
    
      
    
    
    
    <item>
      <title>データ構造実機実験レポート5——ハフマン木の符号化と復号、ソート二分木の構築とノード削除</title>
      <link>http://localhost:1313/ja/post/code/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E6%9C%BA%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A5%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E7%BC%96%E7%A0%81%E5%92%8C%E8%AF%91%E7%A0%81%E6%8E%92%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA%E5%92%8C%E8%8A%82%E7%82%B9%E5%88%A0%E9%99%A4/</link>
      <pubDate>Tue, 12 Dec 2023 14:54:04 &#43;0800</pubDate><author>lvbowen040427@163.com (孤筝)</author>
      <guid>http://localhost:1313/ja/post/code/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E6%9C%BA%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A5%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E7%BC%96%E7%A0%81%E5%92%8C%E8%AF%91%E7%A0%81%E6%8E%92%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA%E5%92%8C%E8%8A%82%E7%82%B9%E5%88%A0%E9%99%A4/</guid>
      <description><![CDATA[<h1>データ構造実機実験レポート5——ハフマン木の符号化と復号、ソート二分木の構築とノード削除</h1><p>作者: 孤筝 (lvbowen040427@163.com)</p>
          <h1 id="ハフマン木の符号化と復号化の実装">
<a class="header-anchor" href="#%e3%83%8f%e3%83%95%e3%83%9e%e3%83%b3%e6%9c%a8%e3%81%ae%e7%ac%a6%e5%8f%b7%e5%8c%96%e3%81%a8%e5%be%a9%e5%8f%b7%e5%8c%96%e3%81%ae%e5%ae%9f%e8%a3%85"></a>
ハフマン木の符号化と復号化の実装
</h1><h3 id="a-問題分析">
<a class="header-anchor" href="#a-%e5%95%8f%e9%a1%8c%e5%88%86%e6%9e%90"></a>
a. 問題分析
</h3><h4 id="目標">
<a class="header-anchor" href="#%e7%9b%ae%e6%a8%99"></a>
目標：
</h4><p>ハフマン木の符号化と復号化を実現する。</p>
<h4 id="問題">
<a class="header-anchor" href="#%e5%95%8f%e9%a1%8c"></a>
問題：
</h4><ol>
<li>ハフマン木の構築プロセスは正しいか？</li>
<li>ハフマン符号は正しく生成されているか？</li>
<li>ハフマン符号化と復号化のプロセスは正しく行われているか？</li>
<li>同じ頻度の文字を正しく処理できるか？</li>
</ol>
<h3 id="b-アルゴリズム設計">
<a class="header-anchor" href="#b-%e3%82%a2%e3%83%ab%e3%82%b4%e3%83%aa%e3%82%ba%e3%83%a0%e8%a8%ad%e8%a8%88"></a>
b. アルゴリズム設計
</h3><h4 id="1-ハフマン木の構築">
<a class="header-anchor" href="#1-%e3%83%8f%e3%83%95%e3%83%9e%e3%83%b3%e6%9c%a8%e3%81%ae%e6%a7%8b%e7%af%89"></a>
1. ハフマン木の構築：
</h4><ul>
<li>入力テキストに基づいて文字の頻度を計算する。</li>
<li>優先度付きキュー（最小ヒープ）を使用してハフマン木を構築する。</li>
</ul>
<p><strong>入力：</strong> 文字頻度のマッピング <code>frequencies</code>。
<strong>出力：</strong> ハフマン木のルートノード <code>root</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">HuffmanNode</span><span class="o">*</span> <span class="nf">buildHuffmanTree</span><span class="p">(</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">frequencies</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 1. 優先度付きキュー（最小ヒープ）を作成してハフマン木を構築
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">HuffmanNode</span><span class="o">*</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">HuffmanNode</span><span class="o">*&gt;</span><span class="p">,</span> <span class="n">CompareNodes</span><span class="o">&gt;</span> <span class="n">minHeap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 2. リーフノードを作成して最小ヒープに追加
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">entry</span> <span class="p">:</span> <span class="n">frequencies</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">HuffmanNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HuffmanNode</span><span class="p">(</span><span class="n">entry</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">entry</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">minHeap</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 3. ハフマン木を構築
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="n">minHeap</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">HuffmanNode</span><span class="o">*</span> <span class="n">left</span> <span class="o">=</span> <span class="n">minHeap</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">minHeap</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">HuffmanNode</span><span class="o">*</span> <span class="n">right</span> <span class="o">=</span> <span class="n">minHeap</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">minHeap</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">HuffmanNode</span><span class="o">*</span> <span class="n">internalNode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HuffmanNode</span><span class="p">(</span><span class="sc">&#39;$&#39;</span><span class="p">,</span> <span class="n">left</span><span class="o">-&gt;</span><span class="n">frequency</span> <span class="o">+</span> <span class="n">right</span><span class="o">-&gt;</span><span class="n">frequency</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">internalNode</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">internalNode</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">minHeap</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">internalNode</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 4. ハフマン木のルートノードを返す
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">minHeap</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="2-ハフマン符号の生成">
<a class="header-anchor" href="#2-%e3%83%8f%e3%83%95%e3%83%9e%e3%83%b3%e7%ac%a6%e5%8f%b7%e3%81%ae%e7%94%9f%e6%88%90"></a>
2. ハフマン符号の生成：
</h4><ul>
<li>再帰的にハフマン木を走査し、各文字のハフマン符号を生成する。
<strong>入力：</strong> ハフマン木のルートノード <code>root</code>、空の文字列 <code>code</code>、空のマッピング <code>huffmanCodes</code>。
<strong>出力：</strong> 文字からハフマン符号へのマッピング <code>huffmanCodes</code>。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">generateHuffmanCodes</span><span class="p">(</span><span class="n">HuffmanNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">string</span> <span class="n">code</span><span class="p">,</span> <span class="n">map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">huffmanCodes</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 1. 再帰終了条件：リーフノードに到達
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 2. リーフノードの場合、文字と対応するハフマン符号をマッピングに保存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">!=</span> <span class="sc">&#39;$&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">huffmanCodes</span><span class="p">[</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">]</span> <span class="o">=</span> <span class="n">code</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 3. 左部分木と右部分木のハフマン符号を再帰的に生成
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">generateHuffmanCodes</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">code</span> <span class="o">+</span> <span class="s">&#34;0&#34;</span><span class="p">,</span> <span class="n">huffmanCodes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">generateHuffmanCodes</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">code</span> <span class="o">+</span> <span class="s">&#34;1&#34;</span><span class="p">,</span> <span class="n">huffmanCodes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="3-ハフマン符号化">
<a class="header-anchor" href="#3-%e3%83%8f%e3%83%95%e3%83%9e%e3%83%b3%e7%ac%a6%e5%8f%b7%e5%8c%96"></a>
3. ハフマン符号化：
</h4><ul>
<li>入力テキストを走査し、生成されたハフマン符号で各文字を置き換える。
<strong>入力：</strong> 元のテキスト <code>text</code>、ハフマン符号のマッピング <code>huffmanCodes</code>。
<strong>出力：</strong> 符号化されたテキスト <code>encodedText</code>。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">string</span> <span class="nf">huffmanEncode</span><span class="p">(</span><span class="n">string</span> <span class="n">text</span><span class="p">,</span> <span class="n">map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">huffmanCodes</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">string</span> <span class="n">encodedText</span> <span class="o">=</span> <span class="s">&#34;&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 元のテキストを走査し、マッピングに基づいて各文字を置き換え
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">char</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">text</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">encodedText</span> <span class="o">+=</span> <span class="n">huffmanCodes</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">encodedText</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="4-ハフマン復号化">
<a class="header-anchor" href="#4-%e3%83%8f%e3%83%95%e3%83%9e%e3%83%b3%e5%be%a9%e5%8f%b7%e5%8c%96"></a>
4. ハフマン復号化：
</h4><ul>
<li>ハフマン符号を走査し、符号の'0&rsquo;と'1&rsquo;に従ってハフマン木の左部分木または右部分木を訪問し、リーフノードに到達したらその文字を復号結果に追加する。
<strong>入力：</strong> 符号化されたテキスト <code>encodedText</code>、ハフマン木のルートノード <code>root</code>。
<strong>出力：</strong> 復号化されたテキスト <code>decodedText</code>。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">string</span> <span class="nf">huffmanDecode</span><span class="p">(</span><span class="n">string</span> <span class="n">encodedText</span><span class="p">,</span> <span class="n">HuffmanNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">string</span> <span class="n">decodedText</span> <span class="o">=</span> <span class="s">&#34;&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">HuffmanNode</span><span class="o">*</span> <span class="n">current</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ハフマン符号を走査
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">char</span> <span class="nl">bit</span> <span class="p">:</span> <span class="n">encodedText</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// &#39;0&#39; と &#39;1&#39; に従って左部分木または右部分木を訪問
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">bit</span> <span class="o">==</span> <span class="sc">&#39;0&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// リーフノードに到達した場合、文字を復号結果に追加し、ルートノードにリセット
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">!=</span> <span class="sc">&#39;$&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">decodedText</span> <span class="o">+=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">current</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">decodedText</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="c-データ構造設計">
<a class="header-anchor" href="#c-%e3%83%87%e3%83%bc%e3%82%bf%e6%a7%8b%e9%80%a0%e8%a8%ad%e8%a8%88"></a>
c. データ構造設計
</h3><ul>
<li><strong>HuffmanNode 構造体：</strong>
<ul>
<li>文字、頻度、および左右の子ノードポインタを格納。</li>
</ul>
</li>
<li><strong>CompareNodes 構造体：</strong>
<ul>
<li>ノード比較のルールを定義し、最小ヒープを構築。</li>
</ul>
</li>
<li><strong>std::priority_queue：</strong>
<ul>
<li>HuffmanNode ポインタを格納する最小ヒープで、ハフマン木の構築に使用。</li>
</ul>
</li>
<li><strong>std::map&lt;char, int&gt;：</strong>
<ul>
<li>文字頻度を格納。</li>
</ul>
</li>
</ul>
<h3 id="d-デバッグプロセス">
<a class="header-anchor" href="#d-%e3%83%87%e3%83%90%e3%83%83%e3%82%b0%e3%83%97%e3%83%ad%e3%82%bb%e3%82%b9"></a>
d. デバッグプロセス
</h3><ol>
<li>
<p><strong>ハフマン木の構築：</strong></p>
<ul>
<li>頻度計算が正しいか確認。</li>
<li>最小ヒープの構築が期待通りに行われているか確認。</li>
</ul>
</li>
<li>
<p><strong>ハフマン符号の生成：</strong></p>
<ul>
<li>手動で一部の符号を計算し、生成されたハフマン符号が正しいか検証。</li>
</ul>
</li>
<li>
<p><strong>ハフマン符号化と復号化：</strong></p>
<ul>
<li>単純なテストケースを使用し、符号化と復号化の正しさを確認。</li>
<li>特に同じ頻度の文字の場合、その相対順序が変わらないことを確認。</li>
</ul>
</li>
</ol>
<h3 id="e-出力結果">
<a class="header-anchor" href="#e-%e5%87%ba%e5%8a%9b%e7%b5%90%e6%9e%9c"></a>
e. 出力結果
</h3><p>プログラムを実行し、テストケース（例: &ldquo;zhubingqianwoxihuanni&rdquo; を入力）を使用して出力結果を確認。出力にはハフマン符号、符号化されたテキスト、復号化されたテキストが含まれ、その正しさを検証する。
<img src="https://cdn.jsdelivr.net/gh/GuZhengSVT/Hugo-media/2023/12/1993178519.png" alt="Pasted image 20231110154039.png"></p>
<p>以下は入力textが&quot;hello world&quot;の場合の出力結果</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-plaintext" data-lang="plaintext"><span class="line"><span class="cl">Huffman Codes:
</span></span><span class="line"><span class="cl">d: 00
</span></span><span class="line"><span class="cl">r: 010
</span></span><span class="line"><span class="cl">$: 011
</span></span><span class="line"><span class="cl">w: 1000
</span></span><span class="line"><span class="cl">e: 1001
</span></span><span class="line"><span class="cl">o: 101
</span></span><span class="line"><span class="cl">l: 110
</span></span><span class="line"><span class="cl">h: 1110
</span></span><span class="line"><span class="cl"> : 1111
</span></span><span class="line"><span class="cl">Encoded Text: 111000110010100010010010110111010010011110111100
</span></span><span class="line"><span class="cl">Decoded Text: hello world
</span></span></code></pre></div><h3 id="f-ソースコード">
<a class="header-anchor" href="#f-%e3%82%bd%e3%83%bc%e3%82%b9%e3%82%b3%e3%83%bc%e3%83%89"></a>
f. ソースコード
</h3><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// ハフマン木のノード構造を定義
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">HuffmanNode</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">frequency</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">HuffmanNode</span> <span class="o">*</span><span class="n">left</span><span class="p">,</span> <span class="o">*</span><span class="n">right</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">HuffmanNode</span><span class="p">(</span><span class="kt">char</span> <span class="n">d</span><span class="p">,</span> <span class="kt">int</span> <span class="n">freq</span><span class="p">)</span> <span class="o">:</span> <span class="n">data</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <span class="n">frequency</span><span class="p">(</span><span class="n">freq</span><span class="p">),</span> <span class="n">left</span><span class="p">(</span><span class="k">nullptr</span><span class="p">),</span> <span class="n">right</span><span class="p">(</span><span class="k">nullptr</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 2つのノードの優先度を比較
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">CompareNodes</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="nf">operator</span><span class="p">()(</span><span class="n">HuffmanNode</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="n">HuffmanNode</span><span class="o">*</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span><span class="c1">//&#39;+&#39;演算子をオーバーロード
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">frequency</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">frequency</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// ハフマン木を構築
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">HuffmanNode</span><span class="o">*</span> <span class="nf">buildHuffmanTree</span><span class="p">(</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">frequencies</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">HuffmanNode</span><span class="o">*</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">HuffmanNode</span><span class="o">*&gt;</span><span class="p">,</span> <span class="n">CompareNodes</span><span class="o">&gt;</span> <span class="n">minHeap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//優先度付きキューテンプレート、要素型HuffmanNode*、コンテナ型vector&lt;HuffmanNode*&gt;、比較規則関数CompareNodes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// リーフノードを作成し、最小ヒープに追加
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">entry</span> <span class="p">:</span> <span class="n">frequencies</span><span class="p">)</span> <span class="p">{</span><span class="c1">//auto、entryの型をfrequenciesのキーと値のペアとして自動判定
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">HuffmanNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HuffmanNode</span><span class="p">(</span><span class="n">entry</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">entry</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">minHeap</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="p">);</span><span class="c1">//キューに追加
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//priority_queueは自動的にキューの優先度を維持
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ハフマン木を構築
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="n">minHeap</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span><span class="c1">//優先度付きキューにノードが1つだけ残ったらルートノード、ループ終了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">HuffmanNode</span><span class="o">*</span> <span class="n">left</span> <span class="o">=</span> <span class="n">minHeap</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">minHeap</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">HuffmanNode</span><span class="o">*</span> <span class="n">right</span> <span class="o">=</span> <span class="n">minHeap</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">minHeap</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">HuffmanNode</span><span class="o">*</span> <span class="n">internalNode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HuffmanNode</span><span class="p">(</span><span class="sc">&#39;$&#39;</span><span class="p">,</span> <span class="n">left</span><span class="o">-&gt;</span><span class="n">frequency</span> <span class="o">+</span> <span class="n">right</span><span class="o">-&gt;</span><span class="n">frequency</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//2つの子ノードのルートノードを作成、frequencyは子ノードのfrequencyの合計
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">internalNode</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">internalNode</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">minHeap</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">internalNode</span><span class="p">);</span><span class="c1">//このルートノードをminHeapに追加して再配置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//ハフマン木を生成、すべての非リーフノードのdataは&#39;$&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ルートノードを返す
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">minHeap</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 再帰的にハフマン符号を生成
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">generateHuffmanCodes</span><span class="p">(</span><span class="n">HuffmanNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">string</span> <span class="n">code</span><span class="p">,</span> <span class="n">map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">huffmanCodes</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">!=</span> <span class="sc">&#39;$&#39;</span><span class="p">)</span> <span class="p">{</span><span class="c1">//リーフノードに到達
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">huffmanCodes</span><span class="p">[</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">]</span> <span class="o">=</span> <span class="n">code</span><span class="p">;</span><span class="c1">//この文字の符号はcode
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">generateHuffmanCodes</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">code</span> <span class="o">+</span> <span class="s">&#34;0&#34;</span><span class="p">,</span> <span class="n">huffmanCodes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">generateHuffmanCodes</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">code</span> <span class="o">+</span> <span class="s">&#34;1&#34;</span><span class="p">,</span> <span class="n">huffmanCodes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//再帰的に実装、左部分木にアクセスすると+0、右部分木にアクセスすると+1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// ハフマン符号化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">string</span> <span class="nf">huffmanEncode</span><span class="p">(</span><span class="n">string</span> <span class="n">text</span><span class="p">,</span> <span class="n">map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">huffmanCodes</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">string</span> <span class="n">encodedText</span> <span class="o">=</span> <span class="s">&#34;&#34;</span><span class="p">;</span><span class="c1">//resultを空文字列で初期化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">char</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">text</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">encodedText</span> <span class="o">+=</span> <span class="n">huffmanCodes</span><span class="p">[</span><span class="n">c</span><span class="p">];</span><span class="c1">//文字cに対応するハフマン符号を追加
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">encodedText</span><span class="p">;</span><span class="c1">//結果を返す
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// ハフマン復号化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">string</span> <span class="nf">huffmanDecode</span><span class="p">(</span><span class="n">string</span> <span class="n">encodedText</span><span class="p">,</span> <span class="n">HuffmanNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">string</span> <span class="n">decodedText</span> <span class="o">=</span> <span class="s">&#34;&#34;</span><span class="p">;</span><span class="c1">//復号結果を空文字列で初期化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">HuffmanNode</span><span class="o">*</span> <span class="n">current</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">char</span> <span class="nl">bit</span> <span class="p">:</span> <span class="n">encodedText</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">bit</span> <span class="o">==</span> <span class="sc">&#39;0&#39;</span><span class="p">)</span> <span class="p">{</span><span class="c1">//&#39;0&#39;を読むと左部分木にアクセス、&#39;1&#39;を読むと右部分木にアクセス
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">!=</span> <span class="sc">&#39;$&#39;</span><span class="p">)</span> <span class="p">{</span><span class="c1">//リーフノードに到達、このハフマン符号の復号結果を確定
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">decodedText</span> <span class="o">+=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">current</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span><span class="c1">//ルートノードに戻り、次の復号を続行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">decodedText</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//string text = &#34;hello world&#34;;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">string</span> <span class="n">text</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">text</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">frequencies</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 文字頻度を計算
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">char</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">text</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">frequencies</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ハフマン木を構築
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">HuffmanNode</span><span class="o">*</span> <span class="n">root</span> <span class="o">=</span> <span class="n">buildHuffmanTree</span><span class="p">(</span><span class="n">frequencies</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ハフマン符号を生成
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span> <span class="n">huffmanCodes</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">generateHuffmanCodes</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="n">huffmanCodes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ハフマン符号を表示
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Huffman Codes:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">entry</span> <span class="p">:</span> <span class="n">huffmanCodes</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">entry</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">entry</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span><span class="c1">//キーと値のペアを表示
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ハフマン符号化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">string</span> <span class="n">encodedText</span> <span class="o">=</span> <span class="n">huffmanEncode</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">huffmanCodes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Encoded Text: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">encodedText</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ハフマン復号化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">string</span> <span class="n">decodedText</span> <span class="o">=</span> <span class="n">huffmanDecode</span><span class="p">(</span><span class="n">encodedText</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Decoded Text: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">decodedText</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="まとめ">
<a class="header-anchor" href="#%e3%81%be%e3%81%a8%e3%82%81"></a>
まとめ
</h3><p>テストを通じて、プログラムがハフマン木の構築、符号化、復号化機能を正しく実装していることを確認。特に同じ頻度の文字の処理に注意し、その相対順序が変わらないことを確認。ハフマン木の構築時、最小ヒープを使用してノードを頻度の昇順で配置。</p>
<h2 id="a-問題分析-1">
<a class="header-anchor" href="#a-%e5%95%8f%e9%a1%8c%e5%88%86%e6%9e%90-1"></a>
a 問題分析
</h2><p>本実験の目標は、ソート二分木に基づくノードの挿入、中間順走査、木全体の削除、および単一ノードの削除機能を実装することである。具体的な要求には、<code>struct</code>を使用してノードを実装し、ノードの挿入と削除機能を実装することが含まれる。</p>
<h2 id="b-アルゴリズム設計-1">
<a class="header-anchor" href="#b-%e3%82%a2%e3%83%ab%e3%82%b4%e3%83%aa%e3%82%ba%e3%83%a0%e8%a8%ad%e8%a8%88-1"></a>
b アルゴリズム設計
</h2><h3 id="ノード挿入アルゴリズム設計">
<a class="header-anchor" href="#%e3%83%8e%e3%83%bc%e3%83%89%e6%8c%bf%e5%85%a5%e3%82%a2%e3%83%ab%e3%82%b4%e3%83%aa%e3%82%ba%e3%83%a0%e8%a8%ad%e8%a8%88"></a>
ノード挿入アルゴリズム設計
</h3><p>ノード挿入のアルゴリズムは再帰的アルゴリズムです。ノード値と現在のノード値を比較し、左部分木または右部分木に挿入します。現在の部分木が空の場合、新しいノードを作成して返します。そうでない場合、挿入関数を再帰的に呼び出します。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">TreeNode</span><span class="o">*</span> <span class="nf">insert</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="ソート二分木構築アルゴリズム設計">
<a class="header-anchor" href="#%e3%82%bd%e3%83%bc%e3%83%88%e4%ba%8c%e5%88%86%e6%9c%a8%e6%a7%8b%e7%af%89%e3%82%a2%e3%83%ab%e3%82%b4%e3%83%aa%e3%82%ba%e3%83%a0%e8%a8%ad%e8%a8%88"></a>
ソート二分木構築アルゴリズム設計
</h3><p>ソート二分木を構築するアルゴリズムでは、ノード挿入アルゴリズムを使用します。入力シーケンスを走査し、各要素に対してノード挿入関数を呼び出し、ルートノードを更新し続けることで、最終的にソート二分木を得ます。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">TreeNode</span><span class="o">*</span> <span class="nf">buildTree</span><span class="p">(</span><span class="kt">int</span> <span class="n">input</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">root</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">input</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="中間順走査アルゴリズム設計">
<a class="header-anchor" href="#%e4%b8%ad%e9%96%93%e9%a0%86%e8%b5%b0%e6%9f%bb%e3%82%a2%e3%83%ab%e3%82%b4%e3%83%aa%e3%82%ba%e3%83%a0%e8%a8%ad%e8%a8%88"></a>
中間順走査アルゴリズム設計
</h3><p>中間順走査アルゴリズムは、ソート二分木のノード値を出力し、木の構築が正しいことを検証するために使用されます。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">inorderTraversal</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">inorderTraversal</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">inorderTraversal</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="木全体削除アルゴリズム設計">
<a class="header-anchor" href="#%e6%9c%a8%e5%85%a8%e4%bd%93%e5%89%8a%e9%99%a4%e3%82%a2%e3%83%ab%e3%82%b4%e3%83%aa%e3%82%ba%e3%83%a0%e8%a8%ad%e8%a8%88"></a>
木全体削除アルゴリズム設計
</h3><p>木全体を削除するアルゴリズムは再帰的アルゴリズムです。削除関数を再帰的に呼び出し、左部分木と右部分木を削除した後、現在のノードを削除します。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">deleteTree</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">deleteTree</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">deleteTree</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">delete</span> <span class="n">node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="単一ノード削除アルゴリズム設計">
<a class="header-anchor" href="#%e5%8d%98%e4%b8%80%e3%83%8e%e3%83%bc%e3%83%89%e5%89%8a%e9%99%a4%e3%82%a2%e3%83%ab%e3%82%b4%e3%83%aa%e3%82%ba%e3%83%a0%e8%a8%ad%e8%a8%88"></a>
単一ノード削除アルゴリズム設計
</h3><p>単一ノードを削除するアルゴリズムは再帰的アルゴリズムです。ノード値と削除対象の値を比較し、左部分木または右部分木で削除を行います。一致するノードが見つかった場合、3つのケース（子ノードがない場合、子ノードが1つの場合、子ノードが2つの場合）に分けて処理します。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">TreeNode</span><span class="o">*</span> <span class="nf">deleteNode</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 一致するノードを見つける
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">deleteNode</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">deleteNode</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// ノードに子がないか1つの子がある場合
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">TreeNode</span><span class="o">*</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">delete</span> <span class="n">root</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">temp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">TreeNode</span><span class="o">*</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">delete</span> <span class="n">root</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">temp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// ノードに2つの子がある場合、右部分木の最小ノードを見つける
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">TreeNode</span><span class="o">*</span> <span class="n">minRight</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="n">minRight</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">minRight</span> <span class="o">=</span> <span class="n">minRight</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 最小ノードの値を現在のノードにコピー
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">root</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">minRight</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 右部分木から最小ノードを削除
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">deleteNode</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">minRight</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 単一ノード削除のインターフェース関数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">TreeNode</span><span class="o">*</span> <span class="nf">deleteSingleNode</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">nodeToDelete</span> <span class="o">=</span> <span class="n">findNode</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">nodeToDelete</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">root</span> <span class="o">=</span> <span class="n">deleteNode</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="c-データ構造設計-1">
<a class="header-anchor" href="#c-%e3%83%87%e3%83%bc%e3%82%bf%e6%a7%8b%e9%80%a0%e8%a8%ad%e8%a8%88-1"></a>
c データ構造設計
</h3><h4 id="ノード構造">
<a class="header-anchor" href="#%e3%83%8e%e3%83%bc%e3%83%89%e6%a7%8b%e9%80%a0"></a>
ノード構造
</h4><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">TreeNode</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">left</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">right</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">TreeNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="o">:</span> <span class="n">data</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">left</span><span class="p">(</span><span class="k">nullptr</span><span class="p">),</span> <span class="n">right</span><span class="p">(</span><span class="k">nullptr</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h2 id="d-デバッグプロセス-1">
<a class="header-anchor" href="#d-%e3%83%87%e3%83%90%e3%83%83%e3%82%b0%e3%83%97%e3%83%ad%e3%82%bb%e3%82%b9-1"></a>
d デバッグプロセス
</h2><p>デバッグプロセスでは、まず <code>deleteSingleNode</code> 関数が正しく実行されることを確認します。特定のノードを削除した後、二分探索木のノード値を中順走査で検証し、削除操作の正確性を確認します。最後に、出力を通じて実装全体の正確性を検証します。</p>
<h2 id="e-出力結果-1">
<a class="header-anchor" href="#e-%e5%87%ba%e5%8a%9b%e7%b5%90%e6%9e%9c-1"></a>
e 出力結果
</h2><p>入力シーケンス <code>7, 5, 9, 2, 5, 2, 6, 3, 7, 0</code> に対する実験の出力結果は以下の通りです：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ソート済み二分木: 0 2 2 3 5 5 6 7 7 9 
</span></span><span class="line"><span class="cl">ノード 3 を削除後のソート済み二分木: 0 2 2 5 5 6 7 7 9 
</span></span><span class="line"><span class="cl">単一ノード 5 を削除後のソート済み二分木: 0 2 2 6 7 7 9 
</span></span></code></pre></div><p>この出力結果は、単一ノードを削除する機能が追加されていることを示し、ノード 5 を削除後に中間順走査でソート済み二分木のノード値を出力することで、削除操作の正しさを検証しています。</p>
<h2 id="f-ソースコード-1">
<a class="header-anchor" href="#f-%e3%82%bd%e3%83%bc%e3%82%b9%e3%82%b3%e3%83%bc%e3%83%89-1"></a>
f ソースコード
</h2><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 二分木ノードの定義
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">TreeNode</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">left</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">right</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">TreeNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="o">:</span> <span class="n">data</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">left</span><span class="p">(</span><span class="k">nullptr</span><span class="p">),</span> <span class="n">right</span><span class="p">(</span><span class="k">nullptr</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// ソート済み二分木にノードを挿入
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">TreeNode</span><span class="o">*</span> <span class="nf">insert</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 中間順走査
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">inorderTraversal</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">inorderTraversal</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">inorderTraversal</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 木全体を削除
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">deleteTree</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">deleteTree</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">deleteTree</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">delete</span> <span class="n">node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 値がvalのノードを検索
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">TreeNode</span><span class="o">*</span> <span class="nf">findNode</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="k">nullptr</span> <span class="o">||</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">==</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">findNode</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">findNode</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 単一ノードを削除
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">TreeNode</span><span class="o">*</span> <span class="nf">deleteNode</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 一致するノードを検索
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">deleteNode</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">deleteNode</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// ノードが1つまたは子を持たない場合
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">TreeNode</span><span class="o">*</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">delete</span> <span class="n">root</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">temp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">TreeNode</span><span class="o">*</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">delete</span> <span class="n">root</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">temp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// ノードが2つの子を持つ場合、右部分木の最小ノードを検索
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">TreeNode</span><span class="o">*</span> <span class="n">minRight</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="n">minRight</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">minRight</span> <span class="o">=</span> <span class="n">minRight</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 最小ノードの値を現在のノードにコピー
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">root</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">minRight</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 右部分木から最小ノードを削除
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">deleteNode</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">minRight</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 単一ノード削除のインターフェース関数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">TreeNode</span><span class="o">*</span> <span class="nf">deleteSingleNode</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">nodeToDelete</span> <span class="o">=</span> <span class="n">findNode</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">nodeToDelete</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">root</span> <span class="o">=</span> <span class="n">deleteNode</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">input</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ソート済み二分木を構築
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">root</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">input</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ソート済み二分木を表示
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;ソート済み二分木: &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">inorderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ノード3を削除後のソート済み二分木
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">nodeToDelete</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">root</span> <span class="o">=</span> <span class="n">deleteNode</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">nodeToDelete</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;ノード &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">nodeToDelete</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; を削除後のソート済み二分木: &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">inorderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 単一ノード5を削除後のソート済み二分木
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">singleNodeToDelete</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">root</span> <span class="o">=</span> <span class="n">deleteSingleNode</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">singleNodeToDelete</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;単一ノード &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">singleNodeToDelete</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; を削除後のソート済み二分木: &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">inorderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 木全体を削除
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">deleteTree</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div>
        <hr><p>本文 2023-12-12 首发于 <a href='http://localhost:1313/'>孤筝の温暖小家</a>，最后修改于 2023-12-12</p><p>All website licensed under CC BY 4.0</p>]]>
      </description>
        <category>Code</category>
      
    </item>
    
    
      
    
    
    
    <item>
      <title>データ構造実機実験レポート3——KMPアルゴリズムを用いた文字列検索</title>
      <link>http://localhost:1313/ja/post/code/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E6%9C%BA%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A3kmp%E7%AE%97%E6%B3%95%E7%94%A8%E4%BA%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%90%9C%E7%B4%A2/</link>
      <pubDate>Tue, 12 Dec 2023 14:42:01 &#43;0800</pubDate><author>lvbowen040427@163.com (孤筝)</author>
      <guid>http://localhost:1313/ja/post/code/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E6%9C%BA%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A3kmp%E7%AE%97%E6%B3%95%E7%94%A8%E4%BA%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%90%9C%E7%B4%A2/</guid>
      <description><![CDATA[<h1>データ構造実機実験レポート3——KMPアルゴリズムを用いた文字列検索</h1><p>作者: 孤筝 (lvbowen040427@163.com)</p>
          <h1 id="実験目的">
<a class="header-anchor" href="#%e5%ae%9f%e9%a8%93%e7%9b%ae%e7%9a%84"></a>
<strong>実験目的：</strong>
</h1><p>本実験は、KMPアルゴリズムの実装を分析・テストし、文字列検索への応用を研究することを目的とする。</p>
<h1 id="実験内容">
<a class="header-anchor" href="#%e5%ae%9f%e9%a8%93%e5%86%85%e5%ae%b9"></a>
<strong>実験内容：</strong>
</h1><h2 id="a-問題分析">
<a class="header-anchor" href="#a-%e5%95%8f%e9%a1%8c%e5%88%86%e6%9e%90"></a>
<strong>a 問題分析：</strong>
</h2><ul>
<li>最長接頭辞接尾辞マッチングテーブル（LPS配列）を構築し、検索効率を向上させる方法は？</li>
<li>テキスト文字列でマッチングを実行し、LPS配列を利用して不要な文字比較を回避する方法は？</li>
<li>パターン文字列の検索を実現するアルゴリズムを設計する方法は？</li>
</ul>
<h2 id="b-アルゴリズム設計">
<a class="header-anchor" href="#b-%e3%82%a2%e3%83%ab%e3%82%b4%e3%83%aa%e3%82%ba%e3%83%a0%e8%a8%ad%e8%a8%88"></a>
<strong>b アルゴリズム設計：</strong>
</h2><p>KMPアルゴリズムの設計には以下の主要なステップが含まれる：</p>
<ul>
<li>LPS配列の構築：<code>computeLPSArray</code>関数を使用してパターン文字列のLPS配列を計算し、各位置の接頭辞と接尾辞の最長マッチング長を示す。</li>
<li>テキストでのマッチング実行：<code>KMPSearch</code>関数を使用してテキスト文字列内でパターン文字列のマッチングを実行する。LPS配列を利用してインテリジェントにバックトラックし、検索効率を向上させる。</li>
</ul>
<h2 id="c-データ構造設計">
<a class="header-anchor" href="#c-%e3%83%87%e3%83%bc%e3%82%bf%e6%a7%8b%e9%80%a0%e8%a8%ad%e8%a8%88"></a>
<strong>c データ構造設計：</strong>
</h2><p>本実験では以下のデータ構造を使用した：</p>
<ul>
<li>文字列：テキスト文字列とパターン文字列を表す。</li>
<li>ベクトル（vector）：LPS配列を格納する。</li>
<li>整数変数：マッチングプロセス中のインデックスを表す。</li>
</ul>
<h2 id="d-デバッグ過程">
<a class="header-anchor" href="#d-%e3%83%87%e3%83%90%e3%83%83%e3%82%b0%e9%81%8e%e7%a8%8b"></a>
<strong>d デバッグ過程：</strong>
</h2><p>コードの作成とテスト中に、論理エラーや境界条件などの問題が発生した。これらの問題はアルゴリズムの正確性と性能を確保するために注意深くデバッグする必要があった。段階的なデバッグと出力結果の確認を通じて、コードがテキスト内のパターン文字列のマッチング位置を正しく見つけられることを確認した。</p>
<h2 id="e-出力結果">
<a class="header-anchor" href="#e-%e5%87%ba%e5%8a%9b%e7%b5%90%e6%9e%9c"></a>
<strong>e 出力結果：</strong>
</h2><p>以下はいくつかの出力例である：</p>
<ul>
<li>テキスト文字列が&quot;ABABDABACDABABCABAB&quot;、パターン文字列が&quot;ABABCABAB&quot;の場合、KMPアルゴリズムはテキスト内のマッチング位置を見つけた：</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">インデックス 10 でマッチングを発見
</span></span></code></pre></div><ul>
<li>ユーザーが入力したテキスト文字列とパターン文字列の場合、KMPアルゴリズムはユーザー提供のテキスト内でパターンを検索し、マッチング位置を出力する。</li>
</ul>
<h2 id="f-ソースコード">
<a class="header-anchor" href="#f-%e3%82%bd%e3%83%bc%e3%82%b9%e3%82%b3%e3%83%bc%e3%83%89"></a>
f ソースコード：
</h2><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include&lt;bits/stdc++.h&gt;
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// マッチング文字列の最長接頭辞接尾辞マッチングテーブル（LPS配列）を計算
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">computeLPSArray</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">lps</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 前回の最長接頭辞接尾辞マッチングの長さ
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="n">lps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// lps[0] は常に 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">pattern</span><span class="p">.</span><span class="n">length</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">pattern</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">pattern</span><span class="p">[</span><span class="n">length</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">length</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">lps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">i</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">length</span> <span class="o">=</span> <span class="n">lps</span><span class="p">[</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">lps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">i</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// KMPアルゴリズムを使用してテキスト内でマッチング文字列を検索
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">KMPSearch</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">text</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">pattern</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">pattern</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">text</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">lps</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">computeLPSArray</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">lps</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// テキスト用インデックス
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// パターン用インデックス
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">pattern</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">text</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">i</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">j</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// マッチングを発見、開始位置を出力
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;インデックス &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">-</span> <span class="n">j</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; でマッチングを発見&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">j</span> <span class="o">=</span> <span class="n">lps</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">pattern</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">text</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">j</span> <span class="o">=</span> <span class="n">lps</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">i</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// int main() {
</span></span></span><span class="line"><span class="cl"><span class="c1">//     string text = &#34;ABABDABACDABABCABAB&#34;;
</span></span></span><span class="line"><span class="cl"><span class="c1">//     string pattern = &#34;ABABCABAB&#34;;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">//     KMPSearch(text, pattern);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">//     return 0;
</span></span></span><span class="line"><span class="cl"><span class="c1">// }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">string</span> <span class="n">text</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">string</span> <span class="n">pattern</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">text</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">pattern</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">KMPSearch</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">pattern</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div>
        <hr><p>本文 2023-12-12 首发于 <a href='http://localhost:1313/'>孤筝の温暖小家</a>，最后修改于 2023-12-12</p><p>All website licensed under CC BY 4.0</p>]]>
      </description>
        <category>Code</category>
      
    </item>
    
    
      
    
    
    
    <item>
      <title>Pythonの基本データ構造</title>
      <link>http://localhost:1313/ja/post/code/python%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Sun, 27 Aug 2023 21:40:39 &#43;0800</pubDate><author>lvbowen040427@163.com (孤筝)</author>
      <guid>http://localhost:1313/ja/post/code/python%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description><![CDATA[<h1>Pythonの基本データ構造</h1><p>作者: 孤筝 (lvbowen040427@163.com)</p>
          <p><strong>elemは単語element（要素）の略称</strong>であり、プログラムの定義では不確定な型、つまり抽象的なデータ型を表します。</p>
<h1 id="リスト">
<a class="header-anchor" href="#%e3%83%aa%e3%82%b9%e3%83%88"></a>
リスト
</h1><h2 id="定義">
<a class="header-anchor" href="#%e5%ae%9a%e7%be%a9"></a>
定義
</h2><p>順番に並べられた要素からなるコンテナ</p>
<ul>
<li>要素は任意の型で可能</li>
<li>要素は確定した順序で並び、順序性を持つ</li>
</ul>
<h2 id="リストの作成">
<a class="header-anchor" href="#%e3%83%aa%e3%82%b9%e3%83%88%e3%81%ae%e4%bd%9c%e6%88%90"></a>
リストの作成
</h2><p>空のリストインスタンスを作成してから要素を追加する</p>
<ul>
<li>list()</li>
<li>.append()メソッド</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="n">wife</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span><span class="c1">#インスタンス化</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="n">wife</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&#34;西宮硝子&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="n">wife</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&#34;櫻島麻衣&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="n">wife</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&#34;愛莉希雅&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="n">wife</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="s1">&#39;西宮硝子&#39;</span><span class="p">,</span><span class="s1">&#39;櫻島麻衣&#39;</span><span class="p">,</span><span class="s1">&#39;愛莉希雅&#39;</span><span class="p">]</span>
</span></span></code></pre></div><p>直接リストを定義して要素を埋める</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">phones</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&#34;Apple&#34;</span><span class="p">,</span> <span class="s2">&#34;Huawei&#34;</span><span class="p">,</span> <span class="s2">&#34;Xiaomi&#34;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">phones</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="s1">&#39;Apple&#39;</span><span class="p">,</span> <span class="s1">&#39;Huawei&#39;</span><span class="p">,</span> <span class="s1">&#39;Xiaomi&#39;</span><span class="p">]</span>
</span></span></code></pre></div><h2 id="要素の確認">
<a class="header-anchor" href="#%e8%a6%81%e7%b4%a0%e3%81%ae%e7%a2%ba%e8%aa%8d"></a>
要素の確認
</h2><ol>
<li>インデックスの使用
$[i]$でi+1番目の要素を確認</li>
<li>index()メソッド
$$name.index(x)$$
list name内で最初に値がxとなる要素を検索し、そのインデックスを返す</li>
<li>count()メソッド
$$name.count(x)$$
list name内で値がxとなる要素がいくつあるかを確認し、その数を返す</li>
<li>len()メソッド
$$name.len()$$
list name内の要素の総数を検索し、その数を返す</li>
</ol>
<h2 id="新しい要素の追加">
<a class="header-anchor" href="#%e6%96%b0%e3%81%97%e3%81%84%e8%a6%81%e7%b4%a0%e3%81%ae%e8%bf%bd%e5%8a%a0"></a>
新しい要素の追加
</h2><ol>
<li>append()メソッド
$$name.append(x)$$
nameの末尾に要素xを追加する</li>
<li>insert()メソッド
$$name.insert(i,x)$$
オブジェクトxをnameのインデックスiの位置に挿入し、元のiおよびi以降の要素を順番に後ろに移動させる</li>
<li>extend()メソッド
$$name.extend(name2)$$
リストname2をリストnameの後ろに連結する</li>
</ol>
<h2 id="要素の変更">
<a class="header-anchor" href="#%e8%a6%81%e7%b4%a0%e3%81%ae%e5%a4%89%e6%9b%b4"></a>
要素の変更
</h2><ol>
<li>インデックスを指定して要素を直接代入して変更する</li>
</ol>
<h2 id="要素の削除">
<a class="header-anchor" href="#%e8%a6%81%e7%b4%a0%e3%81%ae%e5%89%8a%e9%99%a4"></a>
要素の削除
</h2><ol>
<li>pop()メソッド
$$name.pop()$$
デフォルトでlistの最後の要素を削除
$$name.pop(i)$$
インデックスがiの要素を削除し、後ろの要素を順番に前に移動</li>
<li>remove()メソッド
$$name.remove(x)$$
最初に値がxである要素を削除し、後ろの要素を順番に前に移動</li>
<li>clear()メソッド
$$name.clear()$$
すべての要素を削除（listを空にする）</li>
<li>del<strong>文</strong>
$$del\ name[a:b]$$
delインデックス$[a,b)$の要素を削除、aを含みbを含まない
$del\ name[:]$はlistを空にすることを意味する
$$del\ name[i]$$
インデックスがiの要素を削除</li>
</ol>
<h2 id="リストの反転">
<a class="header-anchor" href="#%e3%83%aa%e3%82%b9%e3%83%88%e3%81%ae%e5%8f%8d%e8%bb%a2"></a>
リストの反転
</h2><ol>
<li>reverse()メソッド
$$name.reverse()$$
リストnameを反転させ、最後の要素が最初の要素になり、以降も同様に順番が逆になります。</li>
<li>スライス法</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">nums</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">new_nums</span><span class="o">=</span><span class="n">nums</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">new_nums</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
</span></span></code></pre></div><p>元のオブジェクトnumsは変更されず、反転されたリストとして新しいオブジェクトnew_numsが生成されます。</p>
<h2 id="リストのソート">
<a class="header-anchor" href="#%e3%83%aa%e3%82%b9%e3%83%88%e3%81%ae%e3%82%bd%e3%83%bc%e3%83%88"></a>
リストのソート
</h2><ol>
<li>sort()メソッド
$$name.sort()$$
$$name.sort(cmp=None,key=None,reverse=False)$$</li>
</ol>
<ul>
<li>
<p>このメソッドは戻り値がなく、元のlistを直接変更します</p>
</li>
<li>
<p>cmpはオプションのパラメータです</p>
</li>
<li>
<p>keyは要素のどのパラメータを比較の重みとして使用するかを指定し、比較可能なオブジェクトから取られる単一のパラメータです</p>
<ul>
<li>比較要素elemが単一のパラメータ（数字や単一の文字など）のみを含む場合、keyパラメータは省略可能です。</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># リストの2番目の要素を取得</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">takeSecond</span><span class="p">(</span><span class="n">elem</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="c1"># リスト</span>
</span></span><span class="line"><span class="cl"><span class="n">random</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 2番目の要素でソートを指定</span>
</span></span><span class="line"><span class="cl"><span class="n">random</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">takeSecond</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">#関数takeSecondを通じてタプルの2番目の要素（重み）を比較するように指定</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># リストを出力</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ソートされたリスト：&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">random</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">ソートされたリスト</span><span class="err">：</span>
</span></span><span class="line"><span class="cl"><span class="p">[(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]</span>
</span></span></code></pre></div><ul>
<li>reverseはソートのルールで、デフォルトはFalseで昇順、Trueは降順です</li>
</ul>
<h1 id="タプル">
<a class="header-anchor" href="#%e3%82%bf%e3%83%97%e3%83%ab"></a>
タプル
</h1><h2 id="定義-1">
<a class="header-anchor" href="#%e5%ae%9a%e7%be%a9-1"></a>
定義
</h2><p>タプル（tuple）は、一連の要素を順番に並べて形成されるコンテナです。
タプルは不変（immutable）であり、リストは可変（mutable）です。</p>
<h2 id="タプルの作成">
<a class="header-anchor" href="#%e3%82%bf%e3%83%97%e3%83%ab%e3%81%ae%e4%bd%9c%e6%88%90"></a>
タプルの作成
</h2><ol>
<li>直接$()$ですべての要素を囲むことで作成、リストの作成は$[]$を使用</li>
<li>時には$()$を使用しなくてもタプルを作成できる（非推奨）</li>
<li>タプルの内包表記</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">atuple</span><span class="o">=</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">31</span><span class="p">,</span><span class="mi">42</span><span class="p">))</span>
</span></span></code></pre></div><ol start="4">
<li>作成するタプルが1つのオブジェクトのみを含む場合、その後にカンマ$","$を追加
そうしないと、括弧付きオブジェクトのデータ型はタプルではなくオブジェクト型になる</li>
<li>空のタプルを作成</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">a</span><span class="o">=</span><span class="nb">tuple</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">b</span><span class="o">=</span><span class="p">()</span>
</span></span></code></pre></div><h2 id="tupleは増減改査を許可しません">
<a class="header-anchor" href="#tuple%e3%81%af%e5%a2%97%e6%b8%9b%e6%94%b9%e6%9f%bb%e3%82%92%e8%a8%b1%e5%8f%af%e3%81%97%e3%81%be%e3%81%9b%e3%82%93"></a>
tupleは増減改査を許可しません
</h2><h2 id="tupleとlistの変換">
<a class="header-anchor" href="#tuple%e3%81%a8list%e3%81%ae%e5%a4%89%e6%8f%9b"></a>
tupleとlistの変換
</h2><p>tuple-&gt;list</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">atuple</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;love&#39;</span><span class="p">,</span><span class="mf">3.334</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">list</span><span class="p">(</span><span class="n">atuple</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;&#39;&#39;この時atupleは依然としてtuple型&#39;&#39;&#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">alist</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">atuple</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;&#39;&#39;alistはlist型&#39;&#39;&#39;</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">atuple</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">出力</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;love&#39;</span><span class="p">,</span> <span class="mf">3.334</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">出力</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;love&#39;</span><span class="p">,</span> <span class="mf">3.334</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">]</span>
</span></span></code></pre></div><p>list-&gt;tuple</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">alist</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mf">3.1415</span><span class="p">,</span><span class="s1">&#39;polaris&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">atuple</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;&#39;&#39;alistは依然としてlist、atupleはtuple&#39;&#39;&#39;</span>
</span></span></code></pre></div><h1 id="dict">
<a class="header-anchor" href="#dict"></a>
dict
</h1><h2 id="定義-2">
<a class="header-anchor" href="#%e5%ae%9a%e7%be%a9-2"></a>
定義
</h2><ul>
<li>辞書（dict）、一連の<strong>キーと値のペア（key-value）</strong> で構成されるデータ構造です。</li>
<li>キーはハッシュ可能な値でなければなりません。例えば==文字列==や数値など。
<ul>
<li>ハッシュ：任意の長さの入力をハッシュ（散列）アルゴリズムを通じて固定長の出力（ハッシュ値）に変換すること。
ハッシュは一種の圧縮マッピングです。</li>
</ul>
</li>
<li>値は任意のオブジェクトを指定できます。</li>
</ul>
<h2 id="辞書の作成">
<a class="header-anchor" href="#%e8%be%9e%e6%9b%b8%e3%81%ae%e4%bd%9c%e6%88%90"></a>
辞書の作成
</h2><ol>
<li>空の辞書を作成してから要素を追加する
識別子とオブジェクト（key&amp;value）を<strong>等号</strong>で接続することに注意
この場合、keyは識別子であり、<strong>識別子の文字列には引用符を付けない</strong></li>
<li>直接中括弧$\{\}$を使用する
keyとvalueを<strong>コロン</strong>で接続することに注意
<strong>この場合、コロンの前がkeyであり、文字列には引用符が必要</strong></li>
<li>dict()関数を使用してキーと値のシーケンス（tuple、listなど）からdictを作成する</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">profile</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;孤筝&#39;</span><span class="p">,</span><span class="n">age</span><span class="o">=</span><span class="mi">19</span><span class="p">,</span><span class="n">爱好</span><span class="o">=</span><span class="s1">&#39;明月栞那&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">profile</span><span class="o">=</span><span class="p">{</span><span class="n">name</span><span class="p">:</span><span class="s1">&#39;孤筝&#39;</span><span class="p">,</span><span class="n">age</span><span class="p">:</span><span class="mi">19</span><span class="p">,</span><span class="n">爱好</span><span class="p">:</span><span class="s1">&#39;明月栞那&#39;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">alist</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span><span class="s1">&#39;孤筝&#39;</span><span class="p">),(</span><span class="s1">&#39;age&#39;</span><span class="p">,</span><span class="mi">19</span><span class="p">),(</span><span class="s1">&#39;爱好&#39;</span><span class="p">,</span><span class="s1">&#39;明月栞那&#39;</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl"><span class="n">profile</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">この場合</span><span class="err">、</span><span class="n">alistはlistのまま</span><span class="err">、</span><span class="n">profileオブジェクトはdict</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">profile</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">出力</span><span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span><span class="s1">&#39;孤筝&#39;</span><span class="p">,</span><span class="s1">&#39;age&#39;</span><span class="p">:</span><span class="mi">19</span><span class="p">,</span><span class="s1">&#39;爱好&#39;</span><span class="p">:</span><span class="s1">&#39;明月栞那&#39;</span><span class="p">}</span>
</span></span></code></pre></div><ol start="4">
<li>辞書内包表記</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">adict</span><span class="o">=</span><span class="p">{</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">)}</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">adict</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">出力</span><span class="p">{</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">:</span><span class="mi">9</span><span class="p">,</span><span class="mi">4</span><span class="p">:</span><span class="mi">16</span><span class="p">,</span><span class="mi">5</span><span class="p">:</span><span class="mi">25</span><span class="p">}</span>
</span></span></code></pre></div><h2 id="要素の確認-1">
<a class="header-anchor" href="#%e8%a6%81%e7%b4%a0%e3%81%ae%e7%a2%ba%e8%aa%8d-1"></a>
要素の確認
</h2><ol>
<li>$$dict[key]$$を使用
dictは辞書名、keyはキー
keyが存在しない場合、KeyValueエラーが発生</li>
<li>$dict.get(key[,value])$を使用
dictは辞書名、keyはキー、valueはオプションパラメータで初期値
keyが存在しない場合、設定したvalueを返し、valueが設定されていない場合はNoneを返す
==キーが辞書に存在しない場合、キーが追加され、valueがデフォルト値に設定されます。==</li>
</ol>
<h2 id="新しい要素の追加-1">
<a class="header-anchor" href="#%e6%96%b0%e3%81%97%e3%81%84%e8%a6%81%e7%b4%a0%e3%81%ae%e8%bf%bd%e5%8a%a0-1"></a>
新しい要素の追加
</h2>$$dict[key]=value$$<p>
keyは新しいキーで、valueは対応する値です</p>
<h2 id="要素の変更-1">
<a class="header-anchor" href="#%e8%a6%81%e7%b4%a0%e3%81%ae%e5%a4%89%e6%9b%b4-1"></a>
要素の変更
</h2>$$dict[key]=new\_value$$<h2 id="要素の削除-1">
<a class="header-anchor" href="#%e8%a6%81%e7%b4%a0%e3%81%ae%e5%89%8a%e9%99%a4-1"></a>
要素の削除
</h2><ol>
<li>$dict.pop(key)$
dictは辞書名、keyはキーで、文字列には引用符が必要</li>
<li>del関数
$$del\ dict[key]$$
dictは辞書名</li>
</ol>
<h2 id="その他の重要な方法">
<a class="header-anchor" href="#%e3%81%9d%e3%81%ae%e4%bb%96%e3%81%ae%e9%87%8d%e8%a6%81%e3%81%aa%e6%96%b9%e6%b3%95"></a>
その他の重要な方法
</h2><h3 id="keyの存在を確認する">
<a class="header-anchor" href="#key%e3%81%ae%e5%ad%98%e5%9c%a8%e3%82%92%e7%a2%ba%e8%aa%8d%e3%81%99%e3%82%8b"></a>
keyの存在を確認する
</h3><ol>
<li>$in,not in$</li>
<li>$dict.has\_key()$関数
存在すればTrueを返し、存在しなければFalseを返す
==Python2でのみ使用可能、Python3では削除==</li>
</ol>
<h3 id="keyのデフォルト値を設定する">
<a class="header-anchor" href="#key%e3%81%ae%e3%83%87%e3%83%95%e3%82%a9%e3%83%ab%e3%83%88%e5%80%a4%e3%82%92%e8%a8%ad%e5%ae%9a%e3%81%99%e3%82%8b"></a>
keyのデフォルト値を設定する
</h3><ol>
<li>まずkeyがdictに存在するかどうかを確認し、存在しない場合は値を割り当てる</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">profile</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;王炳明&#34;</span><span class="p">,</span> <span class="s2">&#34;age&#34;</span><span class="p">:</span> <span class="mi">27</span><span class="p">,</span> <span class="s2">&#34;公众号&#34;</span><span class="p">:</span> <span class="s2">&#34;Python编程时光&#34;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="s2">&#34;gender&#34;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">profile</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">profile</span><span class="p">[</span><span class="s2">&#34;gender&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&#34;male&#34;</span>
</span></span></code></pre></div><ol start="2">
<li>$setdefault()$メソッド
$$dict.setdefault(key,default=None)$$
defaultはkeyが存在しない場合に設定する値で、デフォルトはNone</li>
</ol>
<h1 id="set">
<a class="header-anchor" href="#set"></a>
set
</h1><h2 id="定義-3">
<a class="header-anchor" href="#%e5%ae%9a%e7%be%a9-3"></a>
定義
</h2><p>集合（set）は、数学の集合と同じく、<strong>順序付けされていない</strong>、<strong>重複のない</strong>要素のシーケンスです。
==question==：順序がない場合、print setの際に要素はどのような順序で表示され、保存時はどのような順序になるのでしょうか？</p>
<h2 id="集合の作成">
<a class="header-anchor" href="#%e9%9b%86%e5%90%88%e3%81%ae%e4%bd%9c%e6%88%90"></a>
集合の作成
</h2><ol>
<li><strong>波括弧</strong>を使用して作成します。$\{\}$内に重複した要素を含めることができますが、最終的にsetは重複を削除します。</li>
<li>set()メソッドを使用して作成します。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">aset</span><span class="o">=</span><span class="p">{</span><span class="mi">1314</span><span class="p">,</span><span class="s1">&#39;520&#39;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">aset</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">出力</span><span class="err">：</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span><span class="mi">1314</span><span class="p">,</span><span class="s1">&#39;520&#39;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">bset</span><span class="o">=</span><span class="nb">set</span><span class="p">()</span><span class="c1">#空の集合asetを作成</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">bset</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">出力</span><span class="err">：</span>
</span></span><span class="line"><span class="cl"><span class="nb">set</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">cset</span><span class="o">=</span><span class="nb">set</span><span class="p">([</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="s1">&#39;love&#39;</span><span class="p">,</span><span class="s1">&#39;ishimiya&#39;</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">cset</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">出力</span><span class="err">：</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="s1">&#39;love&#39;</span><span class="p">,</span><span class="s1">&#39;ishimiya&#39;</span><span class="p">}</span>
</span></span></code></pre></div><h2 id="要素の追加">
<a class="header-anchor" href="#%e8%a6%81%e7%b4%a0%e3%81%ae%e8%bf%bd%e5%8a%a0"></a>
要素の追加
</h2><ol>
<li>
<p>$.add()$関数
</p>
$$set.add(elem)$$<p>
==question==：elemが既存のset要素の場合、何が起こるか？
注意：追加する要素がset集合内の要素と重複する場合、何の効果もないが、エラーは発生しない。</p>
<p>追加する要素は<strong>不変型</strong>でなければならない。可変型の要素を追加するとエラーが発生する。</p>
</li>
<li>
<p>$.update()$関数
</p>
$$set.update(ElemType)$$<p>
ElemTypeはシーケンス（string、list、tuple、dict、setなど）でなければならない。</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">aset</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;朱冰倩&#39;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">aset</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;suki&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">aset</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;for&#39;</span><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;&#39;&#39;集合{&#39;for&#39;}を追加&#39;&#39;&#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">aset</span><span class="o">.</span><span class="n">update</span><span class="p">([</span><span class="mi">10000</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;&#39;&#39;リスト[10000]を追加&#39;&#39;&#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">aset</span><span class="o">.</span><span class="n">update</span><span class="p">((</span><span class="s1">&#39;years&#39;</span><span class="p">,))</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;&#39;&#39;タプルを追加、要素が1つの場合カンマを付ける&#39;&#39;&#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">aset</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;name&#39;</span><span class="p">:</span><span class="s1">&#39;guzheng&#39;</span><span class="p">,</span><span class="s1">&#39;age&#39;</span><span class="p">:</span><span class="mi">19</span><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;&#39;&#39;辞書を追加、keyのみsetに追加される&#39;&#39;&#39;</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">aset</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">出力</span><span class="err">：</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span><span class="s1">&#39;朱冰倩&#39;</span><span class="p">,</span><span class="s1">&#39;suki&#39;</span><span class="p">,</span><span class="s1">&#39;for&#39;</span><span class="p">,</span><span class="mi">10000</span><span class="p">,</span><span class="s1">&#39;years&#39;</span><span class="p">,</span><span class="s1">&#39;name&#39;</span><span class="p">,</span><span class="s1">&#39;age&#39;</span><span class="p">}</span>
</span></span></code></pre></div><h2 id="要素の削除-2">
<a class="header-anchor" href="#%e8%a6%81%e7%b4%a0%e3%81%ae%e5%89%8a%e9%99%a4-2"></a>
要素の削除
</h2><ol>
<li>$.remove()$</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">aset</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;朱冰倩&#39;</span><span class="p">,</span><span class="s1">&#39;suki&#39;</span><span class="p">,</span><span class="s1">&#39;for&#39;</span><span class="p">,</span><span class="mi">10000</span><span class="p">,</span><span class="s1">&#39;years&#39;</span><span class="p">,</span><span class="s1">&#39;name&#39;</span><span class="p">,</span><span class="s1">&#39;age&#39;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">aset</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">aset</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;爱&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;&#39;&#39;存在しない要素をremoveするとエラーが発生する&#39;&#39;&#39;</span>
</span></span><span class="line"><span class="cl"><span class="ne">KeyError</span><span class="p">:</span> <span class="s1">&#39;愛&#39;</span>
</span></span></code></pre></div><ol start="2">
<li>$.discard()$
要素が存在すれば削除し、存在しなくてもエラーにならない</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">aset</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;朱冰倩&#39;</span><span class="p">,</span><span class="s1">&#39;suki&#39;</span><span class="p">,</span><span class="s1">&#39;for&#39;</span><span class="p">,</span><span class="mi">10000</span><span class="p">,</span><span class="s1">&#39;years&#39;</span><span class="p">,</span><span class="s1">&#39;age&#39;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">aset</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="s1">&#39;age&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">aset</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="s1">&#39;love&#39;</span><span class="p">)</span>
</span></span></code></pre></div><ol start="3">
<li>$.pop()$
集合からランダムに要素を削除し、パラメータを渡すことはできない</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">aset</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;朱冰倩&#39;</span><span class="p">,</span><span class="s1">&#39;suki&#39;</span><span class="p">,</span><span class="s1">&#39;for&#39;</span><span class="p">,</span><span class="mi">10000</span><span class="p">,</span><span class="s1">&#39;love&#39;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">aset</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">aset</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">出力例</span><span class="err">：</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span><span class="s1">&#39;朱冰倩&#39;</span><span class="p">,</span><span class="s1">&#39;suki&#39;</span><span class="p">,</span><span class="s1">&#39;for&#39;</span><span class="p">,</span><span class="mi">10000</span><span class="p">}</span>
</span></span></code></pre></div><ol start="4">
<li>$.clear()$
集合内の要素をすべて削除する
$$set.clear()$$</li>
</ol>
<h2 id="要素の変更-2">
<a class="header-anchor" href="#%e8%a6%81%e7%b4%a0%e3%81%ae%e5%a4%89%e6%9b%b4-2"></a>
要素の変更
</h2><p>セット内の要素は順序がないため、集合にはインデックスがなく、要素を変更することはできず、追加または削除のみ可能です。</p>
<h2 id="要素の確認-2">
<a class="header-anchor" href="#%e8%a6%81%e7%b4%a0%e3%81%ae%e7%a2%ba%e8%aa%8d-2"></a>
要素の確認
</h2><p>同上、インデックスなしでは要素を確認できません。
<strong>要素数の確認</strong>
</p>
$$len(set)$$<p>
セット内の要素数を返します</p>
<h2 id="集合演算">
<a class="header-anchor" href="#%e9%9b%86%e5%90%88%e6%bc%94%e7%ae%97"></a>
集合演算
</h2><h3 id="和集合">
<a class="header-anchor" href="#%e5%92%8c%e9%9b%86%e5%90%88"></a>
和集合
</h3><p>$union$関数を使用して2つの集合を結合し重複を削除し、結合後の集合Cを返します
</p>
$$aset.union(bset)$$<p>
同等
</p>
$$aset\ |\ bset$$<h3 id="差集合">
<a class="header-anchor" href="#%e5%b7%ae%e9%9b%86%e5%90%88"></a>
差集合
</h3><p>$difference$関数を使用して差集合を求めます：==集合Aに存在する==が==集合Bには存在しない==要素を見つけ、新しい集合Cとして返します。
</p>
$$aset.difference(bset)$$<p>
同等
</p>
$$aset\ -\ bset$$<h3 id="積集合">
<a class="header-anchor" href="#%e7%a9%8d%e9%9b%86%e5%90%88"></a>
積集合
</h3><ol>
<li>$intersection$関数を使用して積集合を求めます：==集合AとBの両方に存在する==要素を見つけ、集合Cとして返します。
$$aset.intersection(bset)$$
または$$bset.intersection(aset)$$
同等
$$aset\ \&\ bset$$
$$bset\ \&\ aset$$</li>
<li>$intersection\_update$関数を使用して積集合を求めます：積集合を見つけasetに代入し、積集合を返しません。
$$aset.intersection\_update()$$</li>
<li>$\&$を使用し、積集合を返しますがaset、bsetは変更しません
$$aset\ \&\ bset$$</li>
</ol>
<h3 id="対称差集合">
<a class="header-anchor" href="#%e5%af%be%e7%a7%b0%e5%b7%ae%e9%9b%86%e5%90%88"></a>
対称差集合
</h3><ol>
<li>$symmetric\_difference$関数を使用し、対称差集合を返します
$$aset.symmetric\_difference(bset)$$</li>
<li>$symmetric\_difference\_update$関数を使用し、対称差集合をasetに返します
$$aset.symmetric\_difference\_update(bset)$$</li>
</ol>
<h2 id="その他">
<a class="header-anchor" href="#%e3%81%9d%e3%81%ae%e4%bb%96"></a>
その他
</h2><ol>
<li>setが特定の要素を含むかどうかを判断するには、inを使用します
$$print(elem\ in\ aset)$$</li>
<li>2つのsetに共通の要素があるかどうかを判断します
$$aset.isdisjoint(bset)$$
共通の要素がある場合はFalseを返します</li>
<li>bsetがasetの部分集合かどうかを判断します
$$bset.issubset(aset)$$
<strong>bsetがasetの部分集合である</strong>場合、Trueを返します</li>
</ol>
<h1 id="イテレータ">
<a class="header-anchor" href="#%e3%82%a4%e3%83%86%e3%83%ac%e3%83%bc%e3%82%bf"></a>
イテレータ
</h1><p>イテレータ</p>
<h2 id="反復可能オブジェクト">
<a class="header-anchor" href="#%e5%8f%8d%e5%be%a9%e5%8f%af%e8%83%bd%e3%82%aa%e3%83%96%e3%82%b8%e3%82%a7%e3%82%af%e3%83%88"></a>
反復可能オブジェクト
</h2><p>forループを利用できるオブジェクトは、すべて反復可能オブジェクトと呼ばれます。</p>
<h2 id="反復可能プロトコル">
<a class="header-anchor" href="#%e5%8f%8d%e5%be%a9%e5%8f%af%e8%83%bd%e3%83%97%e3%83%ad%e3%83%88%e3%82%b3%e3%83%ab"></a>
反復可能プロトコル
</h2><ol>
<li><strong>最初のシナリオ</strong>：あるオブジェクトが内部で<code>__iter__()</code>メソッドを実装し、イテレータインスタンスを返す場合、そのオブジェクトは反復可能オブジェクトです。
<ol>
<li>このシナリオでは、<code>isinstance(my_list,Iterable)</code>はTrueを返します</li>
</ol>
</li>
<li><strong>2番目のシナリオ</strong>：あるオブジェクトが<code>__iter__()</code>を実装していない場合、Pythonインタプリタは<code>__getitem__()</code>メソッドを使用して要素を取得します。これが可能であれば、そのオブジェクトも反復可能オブジェクトです。
<ol>
<li>このタイプの反復可能オブジェクトの場合、<code>isinstance(my_list,Iterable)</code>はFalseを返します</li>
</ol>
</li>
</ol>
<h2 id="イテレータオブジェクト">
<a class="header-anchor" href="#%e3%82%a4%e3%83%86%e3%83%ac%e3%83%bc%e3%82%bf%e3%82%aa%e3%83%96%e3%82%b8%e3%82%a7%e3%82%af%e3%83%88"></a>
イテレータオブジェクト
</h2><p>反復可能なオブジェクトに対してiter関数を使用すると、イテレータオブジェクトが返されます。イテレータオブジェクトに対してはnext関数を使用して要素を取得できます。実行するたびに1つずつ要素を取得し、すべて取得し終わるとStopIterationが発生し、これ以上要素がないことが通知されます。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">alist</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;人&#39;</span><span class="p">,</span><span class="s1">&#39;生&#39;</span><span class="p">,</span><span class="s1">&#39;若&#39;</span><span class="p">,</span><span class="s1">&#39;只&#39;</span><span class="p">,</span><span class="s1">&#39;如&#39;</span><span class="p">,</span><span class="s1">&#39;初&#39;</span><span class="p">,</span><span class="s1">&#39;見&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">gen</span><span class="o">=</span><span class="nb">iter</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">alist</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">gen</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">出力</span><span class="err">：</span>
</span></span><span class="line"><span class="cl"><span class="n">人</span>
</span></span><span class="line"><span class="cl"><span class="n">生</span>
</span></span><span class="line"><span class="cl"><span class="n">若</span>
</span></span><span class="line"><span class="cl"><span class="n">只</span>
</span></span><span class="line"><span class="cl"><span class="n">如</span>
</span></span><span class="line"><span class="cl"><span class="n">初</span>
</span></span><span class="line"><span class="cl"><span class="n">見</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">alist</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">出力</span><span class="err">：</span>
</span></span><span class="line"><span class="cl"><span class="n">人</span>
</span></span><span class="line"><span class="cl"><span class="n">生</span>
</span></span><span class="line"><span class="cl"><span class="n">若</span>
</span></span><span class="line"><span class="cl"><span class="n">只</span>
</span></span><span class="line"><span class="cl"><span class="n">如</span>
</span></span><span class="line"><span class="cl"><span class="n">初</span>
</span></span><span class="line"><span class="cl"><span class="n">見</span>
</span></span></code></pre></div><h2 id="反復可能オブジェクトとイテレータオブジェクト">
<a class="header-anchor" href="#%e5%8f%8d%e5%be%a9%e5%8f%af%e8%83%bd%e3%82%aa%e3%83%96%e3%82%b8%e3%82%a7%e3%82%af%e3%83%88%e3%81%a8%e3%82%a4%e3%83%86%e3%83%ac%e3%83%bc%e3%82%bf%e3%82%aa%e3%83%96%e3%82%b8%e3%82%a7%e3%82%af%e3%83%88"></a>
反復可能オブジェクトとイテレータオブジェクト
</h2><ol>
<li>反復可能オブジェクトは全体を指し、例えばリストのようなものです。</li>
<li>イテレータオブジェクトはiter()関数によって返されるオブジェクトで、このオブジェクトに対してnext()関数を使用して要素を次々と取得できます。</li>
</ol>
<h1 id="generator">
<a class="header-anchor" href="#generator"></a>
generator
</h1><p>ジェネレータは、イテレータのようにforループを使用して要素を取得できる関数です。</p>
<h2 id="ジェネレータの作成">
<a class="header-anchor" href="#%e3%82%b8%e3%82%a7%e3%83%8d%e3%83%ac%e3%83%bc%e3%82%bf%e3%81%ae%e4%bd%9c%e6%88%90"></a>
ジェネレータの作成
</h2><h3 id="リスト内包表記">
<a class="header-anchor" href="#%e3%83%aa%e3%82%b9%e3%83%88%e5%86%85%e5%8c%85%e8%a1%a8%e8%a8%98"></a>
リスト内包表記
</h3><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">alist</span><span class="o">=</span><span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">出力</span><span class="err">：</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;&#39;&#39;
</span></span></span><span class="line"><span class="cl"><span class="s1">[]を使用してリストオブジェクトを作成
</span></span></span><span class="line"><span class="cl"><span class="s1">&#39;&#39;&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">alist</span><span class="o">=</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">出力</span><span class="err">：</span>
</span></span><span class="line"><span class="cl"><span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;&#39;&#39;
</span></span></span><span class="line"><span class="cl"><span class="s1">この場合、alistはジェネレータオブジェクト
</span></span></span><span class="line"><span class="cl"><span class="s1">&#39;&#39;&#39;</span>
</span></span></code></pre></div><h3 id="yield">
<a class="header-anchor" href="#yield"></a>
yield
</h3><p>yieldとrenturnの違い</p>
<ul>
<li>関数がyieldに到達すると、関数の実行は一時停止し、yieldの後の値が返されます。</li>
<li>yieldに何も値が続いていない場合、Noneが返されます。</li>
<li>yieldは値を返しますが、関数は終了しません。この関数を割り当てた識別子を再度呼び出すと、関数は実行を継続します。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">generator</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="n">top</span><span class="o">=</span><span class="mi">5</span>
</span></span><span class="line"><span class="cl">    <span class="n">i</span><span class="o">=</span><span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">top</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;現在の値：&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">        <span class="k">yield</span> <span class="n">i</span>
</span></span><span class="line"><span class="cl">    <span class="k">raise</span> <span class="ne">StopIteration</span>
</span></span><span class="line"><span class="cl"><span class="n">gen</span><span class="o">=</span><span class="n">generator</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">gen</span><span class="p">))</span>
</span></span></code></pre></div>
        <hr><p>本文 2023-08-27 首发于 <a href='http://localhost:1313/'>孤筝の温暖小家</a>，最后修改于 2023-08-27</p><p>All website licensed under CC BY 4.0</p>]]>
      </description>
        <category>Code</category>
      
    </item>
    
    
      
    
    
    
    <item>
      <title>Pythonその他のノート</title>
      <link>http://localhost:1313/ja/post/code/python%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 27 Jun 2023 00:57:42 &#43;0800</pubDate><author>lvbowen040427@163.com (孤筝)</author>
      <guid>http://localhost:1313/ja/post/code/python%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/</guid>
      <description><![CDATA[<h1>Pythonその他のノート</h1><p>作者: 孤筝 (lvbowen040427@163.com)</p>
          <h1 id="コメント">
<a class="header-anchor" href="#%e3%82%b3%e3%83%a1%e3%83%b3%e3%83%88"></a>
コメント
</h1><ul>
<li>単行コメント
$\#$内容</li>
<li>複数行コメント</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="s1">&#39;&#39;&#39;
</span></span></span><span class="line"><span class="cl"><span class="s1">こんにちは、ここ緑色の部分はコメントです
</span></span></span><span class="line"><span class="cl"><span class="s1">ここもコメントです
</span></span></span><span class="line"><span class="cl"><span class="s1">&#39;&#39;&#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">ここはコメントではありません</span>
</span></span><span class="line"><span class="cl"><span class="c1">#単行コメント</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;&#39;&#39;&#39;ここはコメントではありません&#39;&#39;&#39;見えますか？プリントされますか？&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">a</span><span class="o">=</span><span class="s1">&#39;&#39;&#39;こんにちは&#39;&#39;&#39;</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="n">ターミナル</span><span class="err">：</span><span class="ne">SyntaxError</span><span class="p">:</span> <span class="n">invalid</span> <span class="n">syntax</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;&#39;&#39;
</span></span></span><span class="line"><span class="cl"><span class="s1">このように書くとエラーが発生します。コードの途中にコメントを挿入すると実行に影響するようです
</span></span></span><span class="line"><span class="cl"><span class="s1">複数行文字列は&#39;&#39;&#39;</span><span class="n">文字列</span><span class="s1">&#39;&#39;&#39;で定義できますが、コメントが代入操作として解釈されるため、上記のエラーは末尾の1を指しています
</span></span></span><span class="line"><span class="cl"><span class="s1">&#39;&#39;&#39;</span>
</span></span></code></pre></div><h1 id="エンコーディング形式">
<a class="header-anchor" href="#%e3%82%a8%e3%83%b3%e3%82%b3%e3%83%bc%e3%83%87%e3%82%a3%e3%83%b3%e3%82%b0%e5%bd%a2%e5%bc%8f"></a>
エンコーディング形式
</h1><ul>
<li>Python 2.xでは、ソースファイルのデフォルトエンコーディング形式はASCIIです。漢字が含まれている場合、エンコーディング形式を指定しないと正しく読み込んだり出力したりできません。以下のコードをソースファイルの先頭に置くことで、エンコーディング形式をUTF-8に指定できます。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># -*- coding: UTF-8 -*-</span>
</span></span></code></pre></div><p>Python 3.xでは、ソースファイルのデフォルトエンコーディング形式はUTF-8です。そのため、Python 3.xを使用する場合、通常はエンコーディング形式を指定する必要はありません。</p>
<h1 id="識別子">
<a class="header-anchor" href="#%e8%ad%98%e5%88%a5%e5%ad%90"></a>
識別子
</h1><ul>
<li>識別子はソフトウェアプログラミングにおける一般的な概念で、==変数、関数、インターフェース、クラス==などに名前を付けるために使用されます。</li>
<li>Pythonの識別子は大文字と小文字を区別し、アルファベット、数字、アンダースコアで構成されます。最初の文字はアルファベットまたはアンダースコアでなければならず、数字で始めることはできません。Python 3.xでは、日本語を識別子として使用できます。</li>
<li>アンダースコアで始まる識別子は特別な意味を持ちます。
<ul>
<li>単一のアンダースコアで始まる識別子（例：$\_name$）は、直接アクセスできないクラス属性を表し、クラスが提供するインターフェースを通じてのみアクセスできます。</li>
<li>二重のアンダースコアで始まる識別子（例：$\_\_age$）は、クラスのプライベートメンバーを表します。</li>
<li>二重のアンダースコアで始まり終わる識別子（例：$\_\_init\_\_()$はクラスのコンストラクタ）は、Pythonの組み込み識別子を表します。</li>
</ul>
</li>
</ul>

        <hr><p>本文 2023-06-27 首发于 <a href='http://localhost:1313/'>孤筝の温暖小家</a>，最后修改于 2023-06-27</p><p>All website licensed under CC BY 4.0</p>]]>
      </description>
        <category>Code</category>
      
    </item>
    
    
      
    
    
    
    <item>
      <title>Python基礎関数</title>
      <link>http://localhost:1313/ja/post/code/python%E5%9F%BA%E7%A1%80%E5%87%BD%E6%95%B0/</link>
      <pubDate>Tue, 27 Jun 2023 00:55:01 &#43;0800</pubDate><author>lvbowen040427@163.com (孤筝)</author>
      <guid>http://localhost:1313/ja/post/code/python%E5%9F%BA%E7%A1%80%E5%87%BD%E6%95%B0/</guid>
      <description><![CDATA[<h1>Python基礎関数</h1><p>作者: 孤筝 (lvbowen040427@163.com)</p>
          <h2 id="関数の引数渡し">
<a class="header-anchor" href="#%e9%96%a2%e6%95%b0%e3%81%ae%e5%bc%95%e6%95%b0%e6%b8%a1%e3%81%97"></a>
関数の引数渡し
</h2><p>Pythonでは、関数に引数を渡すことは本質的に代入操作です</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">arr</span> <span class="o">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">a</span><span class="o">=</span><span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="n">func</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</span></span></code></pre></div><ol>
<li>最初に2つの変数arrとaがあり、2つのオブジェクト1と2があります</li>
<li>aは2にバインドされ、func(a)はaがバインドしているオブジェクト2にarrというラベルを貼ります</li>
<li>この時点で、オブジェクト1はまだ作成されておらず、2にはaとarrのラベルが貼られています</li>
<li>$arr=1$操作により、2からarrラベルが剥がされ、オブジェクト1が作成されてarrラベルが貼られます</li>
<li>出力結果</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="mi">2</span>
</span></span></code></pre></div><h2 id="入力と出力">
<a class="header-anchor" href="#%e5%85%a5%e5%8a%9b%e3%81%a8%e5%87%ba%e5%8a%9b"></a>
入力と出力
</h2><h3 id="print関数">
<a class="header-anchor" href="#print%e9%96%a2%e6%95%b0"></a>
print()関数
</h3><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;文字列&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">文字列</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;str1&#34;</span><span class="p">,</span><span class="s2">&#34;str2&#34;</span><span class="p">,</span><span class="s2">&#34;str3&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">str1</span> <span class="n">str2</span> <span class="n">str3</span><span class="c1">#カンマがスペースに置き換わる</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">**</span><span class="n">c</span><span class="p">)</span><span class="c1">#数値を計算してから出力</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="o">/</span><span class="n">c</span><span class="p">))</span><span class="c1">#sum()関数が優先的に実行</span>
</span></span></code></pre></div><p><strong>==プロトタイプ==</strong>
</p>
$$print(self,*args,sep=' ',end='\n',file=None)$$<ul>
<li>sepパラメータ：区切り文字、複数の出力結果（戻り値）間の区切り文字、デフォルトはスペースで手動設定可能</li>
<li>endパラメータ：印刷後の終了方法、デフォルトは$\n$改行、&rsquo; &lsquo;に設定すると改行なし</li>
</ul>
<h3 id="input関数">
<a class="header-anchor" href="#input%e9%96%a2%e6%95%b0"></a>
input()関数
</h3><p><strong>ユーザー入力を取得し、==文字列==として保存</strong>
数字が入力された場合、int()でオブジェクトを数字に変換可能</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="n">age</span><span class="o">=</span><span class="nb">input</span><span class="p">(</span><span class="s2">&#34;年齢を入力してください:&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">年齢を入力してください</span><span class="p">:</span><span class="mi">18</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="nb">print</span><span class="p">(</span><span class="n">age</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;18&#39;</span><span class="c1">#type(age)==&lt;class&#39;str&#39;&gt;</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="n">age</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">age</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="nb">print</span><span class="p">(</span><span class="n">age</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="mi">18</span>
</span></span></code></pre></div><ul>
<li>$input()$には文字列を渡せば、入力プロンプトとして表示される</li>
<li>$int()$を使用する際、余分なスペースがあれば$strip()$メソッドで除去可能、文字列オブジェクト保存時も同様</li>
<li>$input()$は改行を消費し、プログラム実行を一時停止するために使用可能
[[データ型と演算子#文字列フォーマット]]</li>
</ul>
<h2 id="ユーティリティ関数">
<a class="header-anchor" href="#%e3%83%a6%e3%83%bc%e3%83%86%e3%82%a3%e3%83%aa%e3%83%86%e3%82%a3%e9%96%a2%e6%95%b0"></a>
ユーティリティ関数
</h2><h3 id="id">
<a class="header-anchor" href="#id"></a>
id()
</h3><p>例
[[データ型と演算子#代入方法]]
id(変数名)で変数がバインドする<strong>オブジェクト</strong>のメモリアドレスを取得
変数がバインドするオブジェクトが変更されると、クエリ結果も変更され、元のオブジェクトのメモリアドレスは変わらない</p>
<h3 id="type">
<a class="header-anchor" href="#type"></a>
type()
</h3><ul>
<li>1つの引数で<strong>オブジェクト</strong>の型を返す</li>
<li>3つの引数で新しいオブジェクト型を返す
<ul>
<li>type(name,bases,dict)</li>
<li>name &ndash; クラスの名称</li>
<li>bases &ndash; 基底クラスのタプル</li>
<li>dict &ndash; 辞書、クラス内で定義された名前空間変数</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># パラメータの一例</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">```</span><span class="n">python</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">type</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">&lt;</span><span class="nb">type</span> <span class="s1">&#39;int&#39;</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">type</span><span class="p">(</span><span class="s1">&#39;runoob&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&lt;</span><span class="nb">type</span> <span class="s1">&#39;str&#39;</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">type</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="o">&lt;</span><span class="nb">type</span> <span class="s1">&#39;list&#39;</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">type</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span><span class="s1">&#39;zero&#39;</span><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="o">&lt;</span><span class="nb">type</span> <span class="s1">&#39;dict&#39;</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">type</span><span class="p">(</span> <span class="n">x</span> <span class="p">)</span> <span class="o">==</span> <span class="nb">int</span> <span class="c1"># 型が等しいかどうかを判断する</span>
</span></span><span class="line"><span class="cl"><span class="kc">True</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 3つの引数</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">X</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="o">...</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span> 
</span></span><span class="line"><span class="cl">    <span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">X</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nb">object</span><span class="p">,),</span> <span class="nb">dict</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span> <span class="c1"># 新しい型 X を生成する</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">X</span>
</span></span><span class="line"><span class="cl"><span class="o">&lt;</span><span class="k">class</span> <span class="err">&#39;</span><span class="nc">__main__</span><span class="o">.</span><span class="n">X</span><span class="s1">&#39;&gt;</span>
</span></span></code></pre></div><h3 id="next">
<a class="header-anchor" href="#next"></a>
next()
</h3><p>[[基礎データ構造#イテレータオブジェクト]]</p>
<h2 id="文字列関数">
<a class="header-anchor" href="#%e6%96%87%e5%ad%97%e5%88%97%e9%96%a2%e6%95%b0"></a>
文字列関数
</h2><h3 id="文字列オブジェクトの組み込み関数">
<a class="header-anchor" href="#%e6%96%87%e5%ad%97%e5%88%97%e3%82%aa%e3%83%96%e3%82%b8%e3%82%a7%e3%82%af%e3%83%88%e3%81%ae%e7%b5%84%e3%81%bf%e8%be%bc%e3%81%bf%e9%96%a2%e6%95%b0"></a>
文字列オブジェクトの組み込み関数
</h3><ol>
<li>先頭と末尾の空白または文字を削除する$lstrip()$,$rstrip()$,$strip()$</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="nb">str</span><span class="o">=</span><span class="s2">&#34;    人生苦短，我用Python。    &#34;</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="o">.</span><span class="n">lstrip</span><span class="p">())</span><span class="c1">#左側の空白を削除して出力</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="o">.</span><span class="n">rstrip</span><span class="p">())</span><span class="c1">#右側の空白を削除して出力</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span><span class="c1">#左右の空白を削除して出力</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">str_1</span><span class="o">=</span><span class="s1">&#39;333与君相别离，不知何日是归期，我如朝露转瞬晞。333&#39;</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">str_1</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;3&#39;</span><span class="p">))</span><span class="c1">#左右のすべての文字&#39;3&#39;を削除して出力</span>
</span></span></code></pre></div><p>==注意：この関数は本質的に文字列の一部を切り取るものであり、元のオブジェクトを変更するものではない==
$lstrip()$は、文字列の左側の空白または指定された文字を削除した<strong>新しい文字列</strong>を返します。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="nb">str</span><span class="o">=</span><span class="s2">&#34;    人生苦短，我用Python。    &#34;</span>
</span></span><span class="line"><span class="cl"><span class="nb">str</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()</span><span class="c1">#関数を呼び出すだけで代入も出力も行わない</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;&#39;&#39;
</span></span></span><span class="line"><span class="cl"><span class="s1">この場合の出力結果は依然として
</span></span></span><span class="line"><span class="cl"><span class="s1">    人生苦短，我用Python。    
</span></span></span><span class="line"><span class="cl"><span class="s1">左右ともに空白を含む
</span></span></span><span class="line"><span class="cl"><span class="s1">オブジェクトが変更されていないことを示す
</span></span></span><span class="line"><span class="cl"><span class="s1">&#39;&#39;&#39;</span>
</span></span></code></pre></div><ol start="2">
<li>文字列が特定の文字列で始まる/終わるかどうかを判定する$startswith()$,$endswith()$
該当すればTrue、しなければFalseを返す</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="nb">str</span><span class="o">=</span><span class="s2">&#34;山有木兮木有枝，心悦君兮君不知。&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="o">.</span><span class="n">starswith</span><span class="p">(</span><span class="s2">&#34;山&#34;</span><span class="p">))</span><span class="c1">#Trueを返して出力</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;不知&#39;</span><span class="p">))</span><span class="c1">#&#39;。&#39;がないためFalseを返して出力</span>
</span></span></code></pre></div><ol start="3">
<li>
<p>文字列をフォーマットする</p>
$$f"文字列内容{他の文字列変数名}文字列内容"$$<p>
フォーマットされた文字列を返す
<a href="">未記入</a></p>
</li>
<li>
<p>文字列を分割する$split()$
特定の文字で文字列をいくつかの部分文字列に分割し、部分文字列には区切り文字を含まず、文字列リストを返す</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="nb">str</span><span class="o">=</span><span class="s1">&#39;根，紧握在地下，叶，相触在云里，每一阵风过，我们都互相致意。&#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">strP</span><span class="o">=</span><span class="nb">str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;，&#39;</span><span class="p">)</span><span class="c1">#中英文の句読点に注意</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span><span class="c1">#元の文字列オブジェクトを出力</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">strP</span><span class="p">)</span><span class="c1">#分割して得られた文字列リストを出力</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">strP</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="c1">#&#34;紧握在地下&#34;を出力</span>
</span></span></code></pre></div><h2 id="数値処理関数">
<a class="header-anchor" href="#%e6%95%b0%e5%80%a4%e5%87%a6%e7%90%86%e9%96%a2%e6%95%b0"></a>
数値処理関数
</h2><ol>
<li>絶対値
$$abs()$$</li>
<li>切り捨て
$$int()$$</li>
<li>四捨五入（整数を返す）
$$round()$$</li>
<li>大小・真偽の判定（ブール関数）
$$bool()$$
[[データ型と演算子#ブール値と空値]]</li>
</ol>
<h2 id="データ型変換関数">
<a class="header-anchor" href="#%e3%83%87%e3%83%bc%e3%82%bf%e5%9e%8b%e5%a4%89%e6%8f%9b%e9%96%a2%e6%95%b0"></a>
データ型変換関数
</h2><ol>
<li>$$int(x [,base])$$
xは元のオブジェクト、baseはオプションのパラメータで、デフォルトは10（10進数を表す）</li>
<li>$$float(x)$$</li>
<li>$$complex(real[,imag])$$
realは実部、imagはオプションの虚部パラメータ</li>
<li>$$str(x)$$</li>
<li>$$repr(x)$$
オブジェクトxを式の文字列に変換（Pythonインタプリタが読み取れる形式）</li>
<li>$$chr(x)$$
整数を1文字に変換</li>
<li>$$ord(x)$$
1文字をその整数値に変換</li>
<li>$$hex(x)$$
整数xを16進形式の<strong>文字列</strong>に変換</li>
<li>$$oct(x)$$
整数xを8進形式==文字列==に変換</li>
<li>$$eval(str)$$
文字列内の有効なPython式を評価し、オブジェクトを返す</li>
<li>$$tuple(s)$$
シーケンスsをタプルに変換して返す</li>
<li>$$list(s)$$</li>
<li>$$set(s)$$
シーケンスsを可変集合に変換</li>
<li>$$frozenset(s)$$
シーケンスsを不変集合に変換</li>
<li>$$dict(d)$$
(key,value)形式のタプルシーケンスdをdictに変換</li>
</ol>
<h3 id="データ型の高低">
<a class="header-anchor" href="#%e3%83%87%e3%83%bc%e3%82%bf%e5%9e%8b%e3%81%ae%e9%ab%98%e4%bd%8e"></a>
データ型の高低
</h3><ol>
<li>
<p>「高いデータ型」と「低いデータ型」は==暗黙的な型変換==においてデータの精度を説明するための概念。</p>
</li>
<li>
<p>==精度==はデータ型が表現できる情報量や詳細度と理解できる。Pythonでは、データ型の「高」「低」は主にその精度によって判断される。</p>
</li>
<li>
<p>ここでの「高い」データ型とは、より多くの情報（またはより正確な情報）を表現できるデータ型を指し、「低い」データ型は表現できる情報が少ない。
具体的には、浮動小数点数は整数よりも「高い」、なぜなら浮動小数点数は整数だけでなく小数も表現できるから。したがって、例では整数は自動的に浮動小数点数に変換され、情報が失われないよう保証される。</p>
</li>
<li>
<p>また、複素数（complex）は浮動小数点数（float）や整数（int）よりも「高い」、なぜなら複素数は実数と虚数を表現できるが、浮動小数点数と整数は実数のみを表現できるから。演算時にオペランドに複素数が含まれる場合、他の浮動小数点数や整数は複素数に変換される。</p>
</li>
<li>
<p>一般的に、Pythonのデータ型の「高低」は以下の順序で理解できる：
ブール（bool）&lt; 整数型（int） &lt; 浮動小数点型（float）&lt; 複素数型（complex）。
この順序は主にデータ型が表現できる情報範囲と精度によって決定される。</p>
</li>
</ol>
<h4 id="異なるデータ型間で自由に変換できるか">
<a class="header-anchor" href="#%e7%95%b0%e3%81%aa%e3%82%8b%e3%83%87%e3%83%bc%e3%82%bf%e5%9e%8b%e9%96%93%e3%81%a7%e8%87%aa%e7%94%b1%e3%81%ab%e5%a4%89%e6%8f%9b%e3%81%a7%e3%81%8d%e3%82%8b%e3%81%8b"></a>
異なるデータ型間で自由に変換できるか
</h4><p>Pythonはいくつかの組み込み関数を提供して異なるデータ型間の変換を実現しているが、例えば$int(), float(), str(), list(), tuple(), set()$など、すべての型のデータが他の任意の型に変換できるわけではない。変換が可能かどうかは、主にデータ自体が<strong>目標の型を表現するのに十分な情報を含んでいるか</strong>による。</p>
<p>例：
整数を文字列に簡単に変換できる、なぜならすべての整数には明確な文字列表現があるから（例えば、整数123は文字列&quot;123&quot;として表現できる）。</p>
<p>同様に、数字のみを含む文字列（例：&ldquo;123&rdquo;）は整数や浮動小数点数に変換できる、なぜならこの文字列には数字を表現するのに十分な情報が含まれているから。</p>
<p>しかし：
数字以外の文字列（例：&ldquo;Hello&rdquo;）は整数や浮動小数点数に変換できない、なぜならこの文字列には数字を表現する情報が含まれていないから。</p>
<p>リストやタプルは、（その要素が不変であれば）集合に変換できるが、整数には変換できない、なぜなら集合やリストの要素を単一の数字として合理的に表現できないから。</p>
<p>総じて、データ型の変換は==無制限ではない==、それは<strong>元のデータが目標の型を表現するのに十分な情報を提供できるか</strong>による。プログラミングで型変換を行う際、この点に注意が必要。</p>
<h2 id="判断とループ文">
<a class="header-anchor" href="#%e5%88%a4%e6%96%ad%e3%81%a8%e3%83%ab%e3%83%bc%e3%83%97%e6%96%87"></a>
判断とループ文
</h2><h3 id="文">
<a class="header-anchor" href="#%e6%96%87"></a>
$if,elif,else$文
</h3><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">if</span> <span class="n">condition1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">条件1が成立する場合の操作</span>
</span></span><span class="line"><span class="cl"><span class="k">elif</span> <span class="n">condition2</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">条件1が不成立で条件2が成立する場合の操作</span>
</span></span><span class="line"><span class="cl"><span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">条件1</span><span class="p">,</span><span class="mi">2</span><span class="n">ともに不成立の場合の操作</span>
</span></span></code></pre></div><p>例:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">name</span><span class="o">=</span><span class="nb">input</span><span class="p">(</span><span class="s1">&#39;Who are you?&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">age</span><span class="o">=</span><span class="nb">input</span><span class="p">(</span><span class="s1">&#39;How ord are you?&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="n">name</span><span class="o">==</span><span class="s1">&#39;朱冰倩&#39;</span><span class="ow">and</span> <span class="n">age</span><span class="o">&gt;=</span><span class="mi">19</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Daring,long time no see.&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">elif</span> <span class="n">name</span><span class="o">==</span><span class="s1">&#39;朱冰倩&#39;</span> <span class="ow">and</span> <span class="n">age</span><span class="o">==</span><span class="mi">18</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Thank you for being in my life.&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">else</span><span class="p">:</span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;こんにちわ。&#39;</span><span class="p">)</span>
</span></span></code></pre></div><ul>
<li>偽値: None、空リスト、空集合、空辞書、空タプル、空文字列、0、Falseなど</li>
<li>真値: 非空リスト、非空集合、非空辞書、非空タプル、非空文字列、非0数値、Trueなど</li>
</ul>
<h3 id="文-1">
<a class="header-anchor" href="#%e6%96%87-1"></a>
$for,break,continue$文
</h3><h4 id="通常のループ">
<a class="header-anchor" href="#%e9%80%9a%e5%b8%b8%e3%81%ae%e3%83%ab%e3%83%bc%e3%83%97"></a>
通常のループ
</h4><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">シーケンス</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="n">tupleなど</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">実行コードブロック</span>
</span></span></code></pre></div><ul>
<li>forはシーケンス中の要素を順番にxに代入する</li>
</ul>
<h4 id="インデックス付きループ">
<a class="header-anchor" href="#%e3%82%a4%e3%83%b3%e3%83%87%e3%83%83%e3%82%af%e3%82%b9%e4%bb%98%e3%81%8d%e3%83%ab%e3%83%bc%e3%83%97"></a>
インデックス付きループ
</h4><ul>
<li>ループ中にインデックスも取得したい場合、$enumerate()$関数を使用できる</li>
<li>$enumerate()$関数は、リストやタプル、文字列などの反復可能オブジェクトをインデックス付きで返す
<ul>
<li>Python 2.3以上で使用可能、2.6でstartパラメータ追加</li>
</ul>
</li>
<li>$$enumerate(sequence,[start=0])$$
<ul>
<li>sequence: 反復可能オブジェクト</li>
<li>start(オプション): インデックスの開始値、デフォルトは0</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">galgames</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;咖啡馆&#39;</span><span class="p">,</span><span class="s1">&#39;千恋万花&#39;</span><span class="p">,</span><span class="s1">&#39;天使骚骚&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">index</span><span class="p">,</span><span class="n">galgame</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">galgames</span><span class="p">,</span><span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;今日は</span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s1">番目の作品</span><span class="si">{</span><span class="n">galgame</span><span class="si">}</span><span class="s1">をプレイ。&#39;</span><span class="p">)</span>
</span></span></code></pre></div><p>出力:
今日は1番目の作品咖啡馆をプレイ。
今日は2番目の作品千恋万花をプレイ。
今日は3番目の作品天使骚骚をプレイ。</p>
<h4 id="break">
<a class="header-anchor" href="#break"></a>
break
</h4><p>現在のループを中断、異なる階層のbreakは異なるループを中断する</p>
<h4 id="continue">
<a class="header-anchor" href="#continue"></a>
continue
</h4><p>continueは後続のコード実行を停止し、次のループに移行する</p>
<h4 id="for-else">
<a class="header-anchor" href="#for-else"></a>
for-else
</h4><ul>
<li>forループ後にforと同じ階層のelseを記述、forループが正常終了した場合、自動的にelseに入る</li>
<li>breakで中断された場合(continueは正常と見なす)、else分岐に入らない</li>
</ul>
<h3 id="while文">
<a class="header-anchor" href="#while%e6%96%87"></a>
while文
</h3><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">while</span> <span class="n">条件式</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">実行文</span>
</span></span></code></pre></div><p>条件式が成立(True)している間、実行文をループ実行；不成立の場合、ループを抜ける
==無限ループを避けるため、実行文がループ条件を破るかbreakをトリガーできるか確認==</p>
<h4 id="while-else">
<a class="header-anchor" href="#while-else"></a>
while-else
</h4><p>for-elseと同様、breakで中断されずにwhileループが終了した場合、後続のelse分岐を実行；異常終了した場合elseは実行されない</p>

        <hr><p>本文 2023-06-27 首发于 <a href='http://localhost:1313/'>孤筝の温暖小家</a>，最后修改于 2023-06-27</p><p>All website licensed under CC BY 4.0</p>]]>
      </description>
        <category>Code</category>
      
    </item>
    
    
      
    
    
    
    <item>
      <title>Pythonのデータ型と演算子</title>
      <link>http://localhost:1313/ja/post/code/python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Tue, 27 Jun 2023 00:49:20 &#43;0800</pubDate><author>lvbowen040427@163.com (孤筝)</author>
      <guid>http://localhost:1313/ja/post/code/python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description><![CDATA[<h1>Pythonのデータ型と演算子</h1><p>作者: 孤筝 (lvbowen040427@163.com)</p>
          <h2 id="定数と変数">
<a class="header-anchor" href="#%e5%ae%9a%e6%95%b0%e3%81%a8%e5%a4%89%e6%95%b0"></a>
定数と変数
</h2><ul>
<li>変数は型宣言不要</li>
<li>Pythonでは$=$で変数に値を代入し、$==$で二つの値が等しいか比較し、等しければTrue、等しくなければFalseを返す。</li>
<li>変数は使用前に必ず代入が必要（C言語とは異なり）、変数は代入後に初めて作成される。
<ul>
<li>変数未定義エラー</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">age</span>
</span></span><span class="line"><span class="cl"><span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">File</span> <span class="s2">&#34;&lt;stdin&gt;&#34;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="ne">NameError</span><span class="p">:</span> <span class="n">name</span> <span class="s1">&#39;age&#39;</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">defined</span>
</span></span></code></pre></div><p>定数——変化しない変数
<strong>Pythonには変数がオブジェクトを変更しないことを保証する仕組みがなく、変更されてもエラーが出ず、C言語のconstのようなものがないため、使用時には十分注意が必要</strong></p>
<h2 id="代入方法">
<a class="header-anchor" href="#%e4%bb%a3%e5%85%a5%e6%96%b9%e6%b3%95"></a>
代入方法
</h2><p>代入演算子$=$は==右結合性==</p>
<ul>
<li>
<p>単一の代入</p>
<ul>
<li>age = 18</li>
</ul>
</li>
<li>
<p>一括代入</p>
<ul>
<li>a = b = c = 1
<ul>
<li>これはC/C++では考えられない:(</li>
</ul>
</li>
</ul>
</li>
<li>
<p>計算後に代入</p>
<ul>
<li>age = 17+1</li>
</ul>
</li>
<li>
<p>個別代入</p>
<ul>
<li>a,b,c=1,2,3
<ul>
<li>a == 1,b == 2,c == 3</li>
</ul>
</li>
</ul>
<p>a = &ldquo;Jack&quot;と書いた時、Pythonインタプリタは以下の2つのことを行う：
メモリに&rsquo;Jack&rsquo;という文字列オブジェクト（定数）を作成；
メモリにaという名前の変数を作成し、&lsquo;Jack&rsquo;を指すようにする。
変数aを別の変数bに代入する操作は、実際には==変数bを変数aが指すデータに向ける==ことであり、例えば以下のコード：</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="s2">&#34;Jack&#34;</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;Jack&#39;</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;Jack&#39;</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">id</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="mi">4332916664</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">id</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="mi">4332916664</span>
</span></span></code></pre></div><p><em><strong>id()関数は変数のメモリアドレスを確認するために使用</strong></em>
[[基礎関数#id()]]</p>
<ul>
<li>もし別の変数をaに代入すると、id(a)は変わり、id(b)は変わらない</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="n">a</span> <span class="o">=</span> <span class="s2">&#34;Ross&#34;</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="n">a</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;Ross&#39;</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="nb">id</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">別の数値</span><span class="err">（</span><span class="mi">4332916664</span><span class="n">とは異なる</span><span class="err">）</span>
</span></span></code></pre></div><h2 id="変数とオブジェクト">
<a class="header-anchor" href="#%e5%a4%89%e6%95%b0%e3%81%a8%e3%82%aa%e3%83%96%e3%82%b8%e3%82%a7%e3%82%af%e3%83%88"></a>
変数とオブジェクト
</h2><blockquote>
<p>Pythonではすべてがオブジェクトであり、数字もオブジェクト、リストもオブジェクト、関数もオブジェクト、何もかもがオブジェクト。変数はオブジェクトへの参照（またはラベルや名前とも呼ばれる）であり、オブジェクトの操作はすべて参照を通じて行われる。</p></blockquote>
<p>例えば</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
</span></span></code></pre></div><ul>
<li>この場合、数字1がオブジェクト、aが変数（変数名）</li>
<li>代入操作$=$は名前をオブジェクトにバインドする（オブジェクト1にラベルaを付ける）。</li>
<li>明らかに、オブジェクトは複数のラベル（変数）をバインドできる。しかし、一つの変数は一つのオブジェクトしかバインドできない。</li>
<li><strong>変数自体には型がなく、型はオブジェクト内に保存され、オブジェクトの型によって決定される</strong>
<ul>
<li>そのためPythonでは変数の型を事前に宣言する必要がなく、オブジェクトのデータ型を自動的に判断する。これはC/C++と大きく異なる点</li>
</ul>
</li>
</ul>
<h2 id="文字列">
<a class="header-anchor" href="#%e6%96%87%e5%ad%97%e5%88%97"></a>
文字列
</h2><ol>
<li>Pythonでは単一文字と文字列を区別しない</li>
<li>シングルクォート$''$またはダブルクォート$""$で文字列を作成できる（混在不可！）</li>
<li>トリプルシングルクォートまたはトリプルダブルクォートで複数行の文字列を作成可能</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="n">name_1</span><span class="o">=</span><span class="s1">&#39;Jack&#39;</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="n">name_2</span><span class="o">=</span><span class="s2">&#34;Rose&#34;</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="n">sentence_1</span><span class="o">=</span><span class="s1">&#39;&#39;&#39;Rose,
</span></span></span><span class="line"><span class="cl"><span class="s1">Jack,
</span></span></span><span class="line"><span class="cl"><span class="s1">You jump,
</span></span></span><span class="line"><span class="cl"><span class="s1">I jump!&#39;&#39;&#39;</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="n">sentence_2</span><span class="o">=</span><span class="s2">&#34;&#34;&#34;Life is short,
</span></span></span><span class="line"><span class="cl"><span class="s2">you need Python.&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl"><span class="c1">#完璧に動作！</span>
</span></span></code></pre></div><ul>
<li>クォートを使用したい場合はエスケープ文字&rdquo;\&ldquo;を追加
[[基礎関数#文字列関数]]</li>
</ul>
<h3 id="文字列フォーマット">
<a class="header-anchor" href="#%e6%96%87%e5%ad%97%e5%88%97%e3%83%95%e3%82%a9%e3%83%bc%e3%83%9e%e3%83%83%e3%83%88"></a>
文字列フォーマット
</h3><h4 id="メソッド">
<a class="header-anchor" href="#%e3%83%a1%e3%82%bd%e3%83%83%e3%83%89"></a>
%メソッド
</h4>$$print('My\ wife\ is\ \%c,she\ is\ \%d.\ '\%(name,age))$$<ul>
<li>$\%$の後はtuple|dictで、フォーマットする値を渡す</li>
<li>プレースホルダの種類：
![[Pasted image 20230628233506.png]]</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;ブローニャ&#39;</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="n">age</span><span class="o">=</span><span class="mi">18</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;My wife`s name is </span><span class="si">%s</span><span class="s1">,she is </span><span class="si">%d</span><span class="s1"> years old.&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">age</span><span class="p">))</span><span class="c1">#順番に%は文字列後の%()内の内容に対応</span>
</span></span><span class="line"><span class="cl"><span class="n">My</span> <span class="n">wife</span><span class="err">`</span><span class="n">s</span> <span class="n">name</span> <span class="ow">is</span> <span class="n">ブローニャ</span><span class="p">,</span><span class="n">she</span> <span class="ow">is</span> <span class="mi">18</span> <span class="n">years</span> <span class="n">old</span><span class="o">.</span>
</span></span></code></pre></div><ul>
<li><strong>応用</strong>
<ul>
<li>$$\%[データ名][整列フラグ][幅].[精度][型]$$</li>
<li>データ名はdict代入用、配列の場合は記入不要</li>
<li>整列フラグ
<ul>
<li>+：正負符号表示</li>
<li>-：左揃え</li>
<li>space：正数の前にspaceを追加して負数と揃える</li>
<li>0：正数の前に0を追加して負数と揃える</li>
</ul>
</li>
<li>幅：フォーマット後の文字列長、不足分は0またはスペースで埋める</li>
<li>精度：小数点以下の桁数</li>
<li>データ型：プレースホルダの種類</li>
</ul>
</li>
</ul>
<h4 id="format">
<a class="header-anchor" href="#format"></a>
format
</h4><ul>
<li>文字列中で$\{ \}$を使用してプレースホルダを設定し、文字列の後に$.format()$関数を続ける。この関数の引数が文字列に埋め込む変数。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;キアナ&#39;</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="n">age</span><span class="o">=</span><span class="mi">18</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;My wife is </span><span class="si">{}</span><span class="s1">,she is </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">age</span><span class="p">))</span><span class="c1">#順番に埋め込む</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;My wife is </span><span class="si">{1}</span><span class="s1">,she is </span><span class="si">{0}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">age</span><span class="p">,</span><span class="n">name</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;&#39;&#39;
</span></span></span><span class="line"><span class="cl"><span class="s1"></span><span class="si">{}</span><span class="s1">内でインデックス使用可能
</span></span></span><span class="line"><span class="cl"><span class="s1"></span><span class="si">{}</span><span class="s1">内の数字は.format()のタプル/辞書のインデックス
</span></span></span><span class="line"><span class="cl"><span class="s1">&#39;&#39;&#39;</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;My wife is </span><span class="si">{name}</span><span class="s1">,she is </span><span class="si">{age}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span><span class="n">age</span><span class="o">=</span><span class="n">age</span><span class="p">))</span><span class="c1">#変数名で直接置換も可能（オブジェクト属性マッピング）</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;My wife is </span><span class="si">{name}</span><span class="s1">,she is </span><span class="si">{age}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;キアナ&#39;</span><span class="p">,</span><span class="n">age</span><span class="o">=</span><span class="mi">18</span><span class="p">))</span><span class="c1">#キーワードマッピング</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="n">list1</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;キアナ&#39;</span><span class="p">,</span><span class="mi">18</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;My wife is </span><span class="si">{0[0]}</span><span class="s2">,she is </span><span class="si">{0[1]}</span><span class="s2">.&#34;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">list1</span><span class="p">))</span><span class="c1">#辞書インデックスでマッピング</span>
</span></span></code></pre></div><ul>
<li><strong>応用</strong>
<ul>
<li>$$\{:[埋め文字][整列方法][符号フラグ][\#][幅][,][.精度][型]\}$$</li>
<li>埋め文字：未記入時はスペースで埋める</li>
<li>整列方法
<ul>
<li><strong>^</strong>：中央揃え</li>
<li>$`<$：左揃え</li>
<li>$`>$：右揃え</li>
</ul>
</li>
<li>符号フラグ
<ul>
<li>+：正負符号表示</li>
<li>space：正数の前にspaceを追加して負数と揃える</li>
</ul>
</li>
<li>$\#$：2進数、8進数、16進数の前に0b、0o、0xを表示するか</li>
<li>幅：出力文字列の総幅</li>
<li>$,$：千単位区切りを使用</li>
<li>精度：小数点以下の桁数</li>
<li>型：プレースホルダの型</li>
</ul>
</li>
</ul>
<h4 id="f-string">
<a class="header-anchor" href="#f-string"></a>
f-string
</h4><p><em><strong>Formatted String Literals（リテラル文字列フォーマット）、略してf-string、Python3.6以降でサポート</strong></em>
文字列の前に$f$を付け、$f-string$を有効にすると、$\{\}$内で直接変数を使用可能</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;My wife is </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">,she is </span><span class="si">{</span><span class="n">age</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
</span></span></code></pre></div><ul>
<li>f-stringもformatのフォーマット制御パラメータをサポート
$$\{変数名:[埋め文字][整列方法][符号フラグ][\#][幅][,][.精度][型]\}$$</li>
</ul>
<h3 id="スライス">
<a class="header-anchor" href="#%e3%82%b9%e3%83%a9%e3%82%a4%e3%82%b9"></a>
⭐スライス
</h3><ul>
<li>スライス可能なオブジェクト：文字列、タプル、リスト
$$name[a:b:c]$$</li>
</ul>
<ol>
<li>選択範囲は$[a,b)$でaを含みbを含まない。aを省略すると0から開始、bを省略すると末尾まで。</li>
<li>cはステップで、スライスの間隔。省略時はデフォルトで1。
==cが負の時は後ろからスライス==</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="n">name</span><span class="o">=</span><span class="s2">&#34;polaris&#34;</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="nb">print</span><span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;ol&#39;</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="nb">print</span><span class="p">(</span><span class="n">name</span><span class="p">(::</span><span class="o">-</span><span class="mi">3</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;sap&#39;</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;&#39;&#39;
</span></span></span><span class="line"><span class="cl"><span class="s1">&#39;ris&#39;からs、&#39;ola&#39;からa、&#39;p&#39;からpを取得
</span></span></span><span class="line"><span class="cl"><span class="s1">&#39;&#39;&#39;</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="nb">print</span><span class="p">(</span><span class="n">name</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;siralop&#39;</span>
</span></span><span class="line"><span class="cl"><span class="c1">#文字列反転</span>
</span></span></code></pre></div><ol start="3">
<li>スライス操作は元のオブジェクトを変更せず、スライス代入でコピーを作成可能</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="n">x</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="n">y</span><span class="o">=</span><span class="n">x</span><span class="p">[:]</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="n">y</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="nb">print</span> <span class="n">x</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="nb">print</span> <span class="n">y</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
</span></span></code></pre></div><h2 id="整数浮動小数点数複素数">
<a class="header-anchor" href="#%e6%95%b4%e6%95%b0%e6%b5%ae%e5%8b%95%e5%b0%8f%e6%95%b0%e7%82%b9%e6%95%b0%e8%a4%87%e7%b4%a0%e6%95%b0"></a>
整数、浮動小数点数、複素数
</h2><ol>
<li>
<p>整数（Int）</p>
<ol>
<li>0x16進数</li>
<li>0o8進数</li>
</ol>
</li>
<li>
<p>浮動小数点数（Float）</p>
<ol>
<li>小数形式</li>
<li>科学記数法、10をeで代替
<ul>
<li>例：1.23e-6</li>
</ul>
</li>
</ol>
</li>
<li>
<p>複素数（Complex）</p>
<ol>
<li>実部+虚部、a+bj</li>
<li>complex(a,b)</li>
<li>a&amp;bはともに浮動小数点数</li>
</ol>
</li>
<li>
<p>[[基礎関数#type()]]</p>
</li>
<li>
<p>剰余（除算の整数部分）
</p>
$$a//b$$</li>
<li>
<p>余り
</p>
$$a\%b$$</li>
<li>
<p>絶対値</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="n">a</span><span class="o">=</span><span class="mi">10</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="n">b</span><span class="o">=</span><span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="n">a</span><span class="o">//</span><span class="n">b</span>
</span></span><span class="line"><span class="cl"><span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="n">a</span><span class="o">%</span><span class="n">b</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span>
</span></span></code></pre></div><h2 id="ブール値とnone値">
<a class="header-anchor" href="#%e3%83%96%e3%83%bc%e3%83%ab%e5%80%a4%e3%81%a8none%e5%80%a4"></a>
ブール値とNone値
</h2><ul>
<li>True：真（非0数値、デフォルト1）</li>
<li>False：偽（=0数値、デフォルト0）</li>
<li>None：空値、0（整数）ではなく、ブール型ではなく<strong>NoneType</strong></li>
</ul>
<ol>
<li>注意事項
<ul>
<li>先頭大文字</li>
<li>すべての計算結果、判断式の呼び出し戻り値がTrueまたはFalseになるプロセスはブール演算と呼べる。例えば比較演算。</li>
</ul>
</li>
<li>以下は偽値に変換
<ul>
<li>0、0.0、-0.0</li>
<li>None</li>
<li>空文字列、空リスト、空タプル、空辞書</li>
</ul>
</li>
<li>以下は真値に変換
<ul>
<li>-1、1または他の非0数値</li>
<li>すべての非空文字列、<code>&quot;False&quot;</code>を含む</li>
<li>すべての非空辞書、非空リスト、非空集合、非空タプル</li>
</ul>
</li>
<li>ブール値は四則演算可能、True == 1、False == 0</li>
</ol>
<h2 id="ブール演算">
<a class="header-anchor" href="#%e3%83%96%e3%83%bc%e3%83%ab%e6%bc%94%e7%ae%97"></a>
ブール演算
</h2><ol>
<li>論理積 $and$
<ul>
<li>すべてがTrueの場合のみ、and演算の結果はTrue</li>
</ul>
</li>
<li>論理和 $or$
<ul>
<li>一つでもTrueがあれば、or演算の結果はTrue</li>
</ul>
</li>
<li>否定 $not$
<ul>
<li><strong>単項演算子</strong>、TrueをFalseに、FalseをTrueに
[[基礎関数#数値処理関数]]</li>
</ul>
</li>
</ol>
<h2 id="演算子">
<a class="header-anchor" href="#%e6%bc%94%e7%ae%97%e5%ad%90"></a>
演算子
</h2><p><strong>Python言語は以下のタイプの演算子をサポート:</strong></p>
<ul>
<li>算術演算子</li>
<li>比較（関係）演算子</li>
<li>代入演算子</li>
<li>論理演算子</li>
<li>ビット演算子</li>
<li>メンバー演算子</li>
<li>同一性演算子</li>
<li>演算子の優先順位</li>
</ul>
<h3 id="算術演算子">
<a class="header-anchor" href="#%e7%ae%97%e8%a1%93%e6%bc%94%e7%ae%97%e5%ad%90"></a>
算術演算子
</h3><ul>
<li>$**$：べき乗、$x**y$はxのy乗を返す
==右から左に結合==(右結合性)</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="mi">2</span><span class="o">**</span><span class="mi">2</span><span class="o">**</span><span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="mi">256</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="mi">64</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="mi">256</span>
</span></span></code></pre></div><ul>
<li>$//$：剰余、商の整数部分を返す</li>
<li><strong>整数と浮動小数点数の混合演算時、整数は浮動小数点数に変換される</strong></li>
</ul>
<h3 id="比較演算子">
<a class="header-anchor" href="#%e6%af%94%e8%bc%83%e6%bc%94%e7%ae%97%e5%ad%90"></a>
比較演算子
</h3><ul>
<li>$==$：二つの<strong>オブジェクト</strong>が等しいか比較
==Pythonの比較演算子は連鎖可能==
$$a>b==cはa>b\ and\ b==cと等価$$</li>
</ul>
<h3 id="代入演算子">
<a class="header-anchor" href="#%e4%bb%a3%e5%85%a5%e6%bc%94%e7%ae%97%e5%ad%90"></a>
代入演算子
</h3><ul>
<li>$**=$：べき乗代入演算子、$$c**=aはc=c**aと等価$$</li>
<li>$//=$：剰余代入演算子、$$c//=aはc=c//aと等価$$</li>
<li>&laquo;=：左シフト代入
$$a<<=2はa=a<<2と等価$$</li>
<li>
<blockquote>
<blockquote>
<p>=：右シフト代入</p></blockquote></blockquote>
</li>
<li>&amp;=：ビットAND代入
$$a\&=bはa=a\&bと等価$$</li>
<li>|=：ビットOR代入</li>
<li>^=：ビットXOR代入</li>
</ul>
<h3 id="ビット演算子">
<a class="header-anchor" href="#%e3%83%93%e3%83%83%e3%83%88%e6%bc%94%e7%ae%97%e5%ad%90"></a>
ビット演算子
</h3><ul>
<li>$\&$：ビットAND==右結合性==</li>
<li>$|$：ビットOR</li>
<li>^：ビットXOR</li>
<li>~：ビットNOT==右結合性==</li>
<li>$<<$：左シフト</li>
<li>$>>$：右シフト</li>
</ul>
<h3 id="論理演算子">
<a class="header-anchor" href="#%e8%ab%96%e7%90%86%e6%bc%94%e7%ae%97%e5%ad%90"></a>
論理演算子
</h3><ul>
<li>$and$：論理積
<ul>
<li>x and y、xがFalseならFalseを返し、それ以外はyの計算値を返す</li>
</ul>
</li>
<li>$or$：論理和
<ul>
<li>x or y、xが非0ならxの値を返し、それ以外はyの計算値を返す</li>
</ul>
</li>
<li>$not$：論理否定
<ul>
<li>not x、xがTrueならFalse、xがFalseならTrueを返す</li>
<li>==右結合性==</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="kc">True</span> <span class="ow">and</span> <span class="kc">True</span>
</span></span><span class="line"><span class="cl"><span class="kc">True</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="kc">True</span> <span class="ow">and</span> <span class="kc">False</span>
</span></span><span class="line"><span class="cl"><span class="kc">False</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="kc">False</span> <span class="ow">and</span> <span class="kc">True</span>
</span></span><span class="line"><span class="cl"><span class="kc">False</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="kc">True</span> <span class="ow">and</span> <span class="mi">0</span><span class="o">+</span><span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="mi">3</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="kc">True</span> <span class="ow">or</span> <span class="kc">False</span>
</span></span><span class="line"><span class="cl"><span class="kc">True</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="mi">0</span> <span class="ow">or</span> <span class="kc">True</span>
</span></span><span class="line"><span class="cl"><span class="kc">True</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="mi">0</span> <span class="ow">or</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="kc">False</span> <span class="ow">or</span> <span class="mi">31</span>
</span></span><span class="line"><span class="cl"><span class="mi">31</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span><span class="ow">not</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="kc">False</span>
</span></span></code></pre></div><h3 id="メンバー演算子">
<a class="header-anchor" href="#%e3%83%a1%e3%83%b3%e3%83%90%e3%83%bc%e6%bc%94%e7%ae%97%e5%ad%90"></a>
メンバー演算子
</h3><ul>
<li>$in$：x in Y（xはオブジェクトまたは変数名、Yは文字列、辞書またはタプル）、指定シーケンスでxが見つかればTrue、それ以外はFalse</li>
<li>$not\ in$：x not in Y、見つからなければTrue</li>
</ul>
<h3 id="同一性演算子">
<a class="header-anchor" href="#%e5%90%8c%e4%b8%80%e6%80%a7%e6%bc%94%e7%ae%97%e5%ad%90"></a>
同一性演算子
</h3><ul>
<li>$is$：二つの識別子が同じオブジェクトを参照しているか判断、つまり本質的に同一か
<ul>
<li>x is y、if id(x)== id(y),return True</li>
</ul>
</li>
<li>$is\ not$：if id(x) != id(y),return True</li>
</ul>
<h3 id="演算子の優先順位">
<a class="header-anchor" href="#%e6%bc%94%e7%ae%97%e5%ad%90%e3%81%ae%e5%84%aa%e5%85%88%e9%a0%86%e4%bd%8d"></a>
⭐演算子の優先順位
</h3><ol>
<li>()：小括弧</li>
<li>$[\ ]$：インデックス演算子</li>
<li>x.attribute：属性アクセス</li>
<li>$**$：べき乗演算</li>
<li>~：ビットNOT</li>
<li>+@、-@：==単項==プラスマイナス（正負符号）
<ul>
<li>+@、-@は==右結合性==単項演算子</li>
</ul>
</li>
<li>$*$、/、%、$//$：乗除、剰余、剰余除算</li>
<li>+、-：二項加減</li>
<li>&laquo;、&raquo;：ビットシフト左右</li>
<li>&amp;：ビットAND</li>
<li>^：ビットXOR</li>
<li>|：ビットOR</li>
<li>$<,<=,>,>=,==,!=$：比較演算子</li>
<li>=，+=，-=……：代入演算子</li>
<li>is，is not：同一性演算子</li>
<li>in，not in：メンバー演算子</li>
<li>not：否定</li>
<li>and：論理積</li>
<li>or：論理和</li>
<li>$,$：カンマ演算子</li>
</ol>

        <hr><p>本文 2023-06-27 首发于 <a href='http://localhost:1313/'>孤筝の温暖小家</a>，最后修改于 2023-06-27</p><p>All website licensed under CC BY 4.0</p>]]>
      </description>
        <category>Code</category>
      
    </item>
    
  </channel>
</rss>
